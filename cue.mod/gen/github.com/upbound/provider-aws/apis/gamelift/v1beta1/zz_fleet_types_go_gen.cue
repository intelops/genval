// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-aws/apis/gamelift/v1beta1

package v1beta1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#CertificateConfigurationInitParameters: {
	// Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are DISABLED and GENERATED. Default value is DISABLED.
	certificateType?: null | string @go(CertificateType,*string)
}

#CertificateConfigurationObservation: {
	// Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are DISABLED and GENERATED. Default value is DISABLED.
	certificateType?: null | string @go(CertificateType,*string)
}

#CertificateConfigurationParameters: {
	// Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are DISABLED and GENERATED. Default value is DISABLED.
	// +kubebuilder:validation:Optional
	certificateType?: null | string @go(CertificateType,*string)
}

#EC2InboundPermissionInitParameters: {
	// Starting value for a range of allowed port numbers.
	fromPort?: null | float64 @go(FromPort,*float64)

	// Range of allowed IP addresses expressed in CIDR notationE.g., 000.000.000.000/[subnet mask] or 0.0.0.0/[subnet mask].
	ipRange?: null | string @go(IPRange,*string)

	// Network communication protocol used by the fleetE.g., TCP or UDP
	protocol?: null | string @go(Protocol,*string)

	// Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than from_port.
	toPort?: null | float64 @go(ToPort,*float64)
}

#EC2InboundPermissionObservation: {
	// Starting value for a range of allowed port numbers.
	fromPort?: null | float64 @go(FromPort,*float64)

	// Range of allowed IP addresses expressed in CIDR notationE.g., 000.000.000.000/[subnet mask] or 0.0.0.0/[subnet mask].
	ipRange?: null | string @go(IPRange,*string)

	// Network communication protocol used by the fleetE.g., TCP or UDP
	protocol?: null | string @go(Protocol,*string)

	// Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than from_port.
	toPort?: null | float64 @go(ToPort,*float64)
}

#EC2InboundPermissionParameters: {
	// Starting value for a range of allowed port numbers.
	// +kubebuilder:validation:Optional
	fromPort?: null | float64 @go(FromPort,*float64)

	// Range of allowed IP addresses expressed in CIDR notationE.g., 000.000.000.000/[subnet mask] or 0.0.0.0/[subnet mask].
	// +kubebuilder:validation:Optional
	ipRange?: null | string @go(IPRange,*string)

	// Network communication protocol used by the fleetE.g., TCP or UDP
	// +kubebuilder:validation:Optional
	protocol?: null | string @go(Protocol,*string)

	// Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than from_port.
	// +kubebuilder:validation:Optional
	toPort?: null | float64 @go(ToPort,*float64)
}

#FleetInitParameters: {
	// Prompts GameLift to generate a TLS/SSL certificate for the fleet. See certificate_configuration.
	certificateConfiguration?: [...#CertificateConfigurationInitParameters] @go(CertificateConfiguration,[]CertificateConfigurationInitParameters)

	// Human-readable description of the fleet.
	description?: null | string @go(Description,*string)

	// Range of IP addresses and port settings that permit inbound traffic to access server processes running on the fleet. See below.
	ec2InboundPermission?: [...#EC2InboundPermissionInitParameters] @go(EC2InboundPermission,[]EC2InboundPermissionInitParameters)

	// Name of an EC2 instance typeE.g., t2.micro
	ec2InstanceType?: null | string @go(EC2InstanceType,*string)

	// Type of fleet. This value must be ON_DEMAND or SPOT. Defaults to ON_DEMAND.
	fleetType?: null | string @go(FleetType,*string)

	// List of names of metric groups to add this fleet to. A metric group tracks metrics across all fleets in the group. Defaults to default.
	metricGroups?: [...null | string] @go(MetricGroups,[]*string)

	// The name of the fleet.
	name?: null | string @go(Name,*string)

	// Game session protection policy to apply to all instances in this fleetE.g., FullProtection. Defaults to NoProtection.
	newGameSessionProtectionPolicy?: null | string @go(NewGameSessionProtectionPolicy,*string)

	// Policy that limits the number of game sessions an individual player can create over a span of time for this fleet. See below.
	resourceCreationLimitPolicy?: [...#ResourceCreationLimitPolicyInitParameters] @go(ResourceCreationLimitPolicy,[]ResourceCreationLimitPolicyInitParameters)

	// Instructions for launching server processes on each instance in the fleet. See below.
	runtimeConfiguration?: [...#RuntimeConfigurationInitParameters] @go(RuntimeConfiguration,[]RuntimeConfigurationInitParameters)

	// ID of the GameLift Script to be deployed on the fleet.
	scriptId?: null | string @go(ScriptID,*string)

	// Key-value map of resource tags.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)
}

#FleetObservation: {
	// Fleet ARN.
	arn?: null | string @go(Arn,*string)

	// Build ARN.
	buildArn?: null | string @go(BuildArn,*string)

	// ID of the GameLift Build to be deployed on the fleet.
	buildId?: null | string @go(BuildID,*string)

	// Prompts GameLift to generate a TLS/SSL certificate for the fleet. See certificate_configuration.
	certificateConfiguration?: [...#CertificateConfigurationObservation] @go(CertificateConfiguration,[]CertificateConfigurationObservation)

	// Human-readable description of the fleet.
	description?: null | string @go(Description,*string)

	// Range of IP addresses and port settings that permit inbound traffic to access server processes running on the fleet. See below.
	ec2InboundPermission?: [...#EC2InboundPermissionObservation] @go(EC2InboundPermission,[]EC2InboundPermissionObservation)

	// Name of an EC2 instance typeE.g., t2.micro
	ec2InstanceType?: null | string @go(EC2InstanceType,*string)

	// Type of fleet. This value must be ON_DEMAND or SPOT. Defaults to ON_DEMAND.
	fleetType?: null | string @go(FleetType,*string)

	// Fleet ID.
	id?: null | string @go(ID,*string)

	// ARN of an IAM role that instances in the fleet can assume.
	instanceRoleArn?: null | string @go(InstanceRoleArn,*string)
	logPaths?: [...null | string] @go(LogPaths,[]*string)

	// List of names of metric groups to add this fleet to. A metric group tracks metrics across all fleets in the group. Defaults to default.
	metricGroups?: [...null | string] @go(MetricGroups,[]*string)

	// The name of the fleet.
	name?: null | string @go(Name,*string)

	// Game session protection policy to apply to all instances in this fleetE.g., FullProtection. Defaults to NoProtection.
	newGameSessionProtectionPolicy?: null | string @go(NewGameSessionProtectionPolicy,*string)

	// Operating system of the fleet's computing resources.
	operatingSystem?: null | string @go(OperatingSystem,*string)

	// Policy that limits the number of game sessions an individual player can create over a span of time for this fleet. See below.
	resourceCreationLimitPolicy?: [...#ResourceCreationLimitPolicyObservation] @go(ResourceCreationLimitPolicy,[]ResourceCreationLimitPolicyObservation)

	// Instructions for launching server processes on each instance in the fleet. See below.
	runtimeConfiguration?: [...#RuntimeConfigurationObservation] @go(RuntimeConfiguration,[]RuntimeConfigurationObservation)

	// Script ARN.
	scriptArn?: null | string @go(ScriptArn,*string)

	// ID of the GameLift Script to be deployed on the fleet.
	scriptId?: null | string @go(ScriptID,*string)

	// Key-value map of resource tags.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)

	// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
	tagsAll?: {[string]: null | string} @go(TagsAll,map[string]*string)
}

#FleetParameters: {
	// ID of the GameLift Build to be deployed on the fleet.
	// +crossplane:generate:reference:type=Build
	// +kubebuilder:validation:Optional
	buildId?: null | string @go(BuildID,*string)

	// Reference to a Build to populate buildId.
	// +kubebuilder:validation:Optional
	buildIdRef?: null | v1.#Reference @go(BuildIDRef,*v1.Reference)

	// Selector for a Build to populate buildId.
	// +kubebuilder:validation:Optional
	buildIdSelector?: null | v1.#Selector @go(BuildIDSelector,*v1.Selector)

	// Prompts GameLift to generate a TLS/SSL certificate for the fleet. See certificate_configuration.
	// +kubebuilder:validation:Optional
	certificateConfiguration?: [...#CertificateConfigurationParameters] @go(CertificateConfiguration,[]CertificateConfigurationParameters)

	// Human-readable description of the fleet.
	// +kubebuilder:validation:Optional
	description?: null | string @go(Description,*string)

	// Range of IP addresses and port settings that permit inbound traffic to access server processes running on the fleet. See below.
	// +kubebuilder:validation:Optional
	ec2InboundPermission?: [...#EC2InboundPermissionParameters] @go(EC2InboundPermission,[]EC2InboundPermissionParameters)

	// Name of an EC2 instance typeE.g., t2.micro
	// +kubebuilder:validation:Optional
	ec2InstanceType?: null | string @go(EC2InstanceType,*string)

	// Type of fleet. This value must be ON_DEMAND or SPOT. Defaults to ON_DEMAND.
	// +kubebuilder:validation:Optional
	fleetType?: null | string @go(FleetType,*string)

	// ARN of an IAM role that instances in the fleet can assume.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/iam/v1beta1.Role
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-aws/config/common.ARNExtractor()
	// +kubebuilder:validation:Optional
	instanceRoleArn?: null | string @go(InstanceRoleArn,*string)

	// Reference to a Role in iam to populate instanceRoleArn.
	// +kubebuilder:validation:Optional
	instanceRoleArnRef?: null | v1.#Reference @go(InstanceRoleArnRef,*v1.Reference)

	// Selector for a Role in iam to populate instanceRoleArn.
	// +kubebuilder:validation:Optional
	instanceRoleArnSelector?: null | v1.#Selector @go(InstanceRoleArnSelector,*v1.Selector)

	// List of names of metric groups to add this fleet to. A metric group tracks metrics across all fleets in the group. Defaults to default.
	// +kubebuilder:validation:Optional
	metricGroups?: [...null | string] @go(MetricGroups,[]*string)

	// The name of the fleet.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Game session protection policy to apply to all instances in this fleetE.g., FullProtection. Defaults to NoProtection.
	// +kubebuilder:validation:Optional
	newGameSessionProtectionPolicy?: null | string @go(NewGameSessionProtectionPolicy,*string)

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	region?: null | string @go(Region,*string)

	// Policy that limits the number of game sessions an individual player can create over a span of time for this fleet. See below.
	// +kubebuilder:validation:Optional
	resourceCreationLimitPolicy?: [...#ResourceCreationLimitPolicyParameters] @go(ResourceCreationLimitPolicy,[]ResourceCreationLimitPolicyParameters)

	// Instructions for launching server processes on each instance in the fleet. See below.
	// +kubebuilder:validation:Optional
	runtimeConfiguration?: [...#RuntimeConfigurationParameters] @go(RuntimeConfiguration,[]RuntimeConfigurationParameters)

	// ID of the GameLift Script to be deployed on the fleet.
	// +kubebuilder:validation:Optional
	scriptId?: null | string @go(ScriptID,*string)

	// Key-value map of resource tags.
	// +kubebuilder:validation:Optional
	tags?: {[string]: null | string} @go(Tags,map[string]*string)
}

#ResourceCreationLimitPolicyInitParameters: {
	// Maximum number of game sessions that an individual can create during the policy period.
	newGameSessionsPerCreator?: null | float64 @go(NewGameSessionsPerCreator,*float64)

	// Time span used in evaluating the resource creation limit policy.
	policyPeriodInMinutes?: null | float64 @go(PolicyPeriodInMinutes,*float64)
}

#ResourceCreationLimitPolicyObservation: {
	// Maximum number of game sessions that an individual can create during the policy period.
	newGameSessionsPerCreator?: null | float64 @go(NewGameSessionsPerCreator,*float64)

	// Time span used in evaluating the resource creation limit policy.
	policyPeriodInMinutes?: null | float64 @go(PolicyPeriodInMinutes,*float64)
}

#ResourceCreationLimitPolicyParameters: {
	// Maximum number of game sessions that an individual can create during the policy period.
	// +kubebuilder:validation:Optional
	newGameSessionsPerCreator?: null | float64 @go(NewGameSessionsPerCreator,*float64)

	// Time span used in evaluating the resource creation limit policy.
	// +kubebuilder:validation:Optional
	policyPeriodInMinutes?: null | float64 @go(PolicyPeriodInMinutes,*float64)
}

#RuntimeConfigurationInitParameters: {
	// Maximum amount of time (in seconds) that a game session can remain in status ACTIVATING.
	gameSessionActivationTimeoutSeconds?: null | float64 @go(GameSessionActivationTimeoutSeconds,*float64)

	// Maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously.
	maxConcurrentGameSessionActivations?: null | float64 @go(MaxConcurrentGameSessionActivations,*float64)

	// Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
	serverProcess?: [...#ServerProcessInitParameters] @go(ServerProcess,[]ServerProcessInitParameters)
}

#RuntimeConfigurationObservation: {
	// Maximum amount of time (in seconds) that a game session can remain in status ACTIVATING.
	gameSessionActivationTimeoutSeconds?: null | float64 @go(GameSessionActivationTimeoutSeconds,*float64)

	// Maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously.
	maxConcurrentGameSessionActivations?: null | float64 @go(MaxConcurrentGameSessionActivations,*float64)

	// Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
	serverProcess?: [...#ServerProcessObservation] @go(ServerProcess,[]ServerProcessObservation)
}

#RuntimeConfigurationParameters: {
	// Maximum amount of time (in seconds) that a game session can remain in status ACTIVATING.
	// +kubebuilder:validation:Optional
	gameSessionActivationTimeoutSeconds?: null | float64 @go(GameSessionActivationTimeoutSeconds,*float64)

	// Maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously.
	// +kubebuilder:validation:Optional
	maxConcurrentGameSessionActivations?: null | float64 @go(MaxConcurrentGameSessionActivations,*float64)

	// Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
	// +kubebuilder:validation:Optional
	serverProcess?: [...#ServerProcessParameters] @go(ServerProcess,[]ServerProcessParameters)
}

#ServerProcessInitParameters: {
	// Number of server processes using this configuration to run concurrently on an instance.
	concurrentExecutions?: null | float64 @go(ConcurrentExecutions,*float64)

	// Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances C:\game, and for Linux instances /local/game.
	launchPath?: null | string @go(LaunchPath,*string)

	// Optional list of parameters to pass to the server executable on launch.
	parameters?: null | string @go(Parameters,*string)
}

#ServerProcessObservation: {
	// Number of server processes using this configuration to run concurrently on an instance.
	concurrentExecutions?: null | float64 @go(ConcurrentExecutions,*float64)

	// Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances C:\game, and for Linux instances /local/game.
	launchPath?: null | string @go(LaunchPath,*string)

	// Optional list of parameters to pass to the server executable on launch.
	parameters?: null | string @go(Parameters,*string)
}

#ServerProcessParameters: {
	// Number of server processes using this configuration to run concurrently on an instance.
	// +kubebuilder:validation:Optional
	concurrentExecutions?: null | float64 @go(ConcurrentExecutions,*float64)

	// Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances C:\game, and for Linux instances /local/game.
	// +kubebuilder:validation:Optional
	launchPath?: null | string @go(LaunchPath,*string)

	// Optional list of parameters to pass to the server executable on launch.
	// +kubebuilder:validation:Optional
	parameters?: null | string @go(Parameters,*string)
}

// FleetSpec defines the desired state of Fleet
#FleetSpec: {
	v1.#ResourceSpec
	forProvider: #FleetParameters @go(ForProvider)

	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #FleetInitParameters @go(InitProvider)
}

// FleetStatus defines the observed state of Fleet.
#FleetStatus: {
	v1.#ResourceStatus
	atProvider?: #FleetObservation @go(AtProvider)
}

// Fleet is the Schema for the Fleets API. Provides a GameLift Fleet resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws},path=fleet
#Fleet: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.ec2InstanceType) || (has(self.initProvider) && has(self.initProvider.ec2InstanceType))",message="spec.forProvider.ec2InstanceType is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	spec:    #FleetSpec   @go(Spec)
	status?: #FleetStatus @go(Status)
}

// FleetList contains a list of Fleets
#FleetList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#Fleet] @go(Items,[]Fleet)
}
