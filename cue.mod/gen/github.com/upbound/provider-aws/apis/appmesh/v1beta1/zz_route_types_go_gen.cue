// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-aws/apis/appmesh/v1beta1

package v1beta1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#ActionWeightedTargetInitParameters: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#ActionWeightedTargetObservation: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#ActionWeightedTargetParameters: {
	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Optional
	weight?: null | float64 @go(Weight,*float64)
}

#GRPCRouteActionInitParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#WeightedTargetInitParameters] @go(WeightedTarget,[]WeightedTargetInitParameters)
}

#GRPCRouteActionObservation: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#WeightedTargetObservation] @go(WeightedTarget,[]WeightedTargetObservation)
}

#GRPCRouteActionParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Optional
	weightedTarget: [...#WeightedTargetParameters] @go(WeightedTarget,[]WeightedTargetParameters)
}

#GRPCRouteMatchInitParameters: {
	// Data to match from the gRPC request.
	metadata?: [...#MetadataInitParameters] @go(Metadata,[]MetadataInitParameters)

	// Method name to match from the request. If you specify a name, you must also specify a service_name.
	methodName?: null | string @go(MethodName,*string)

	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Fully qualified domain name for the service to match from the request.
	serviceName?: null | string @go(ServiceName,*string)
}

#GRPCRouteMatchObservation: {
	// Data to match from the gRPC request.
	metadata?: [...#MetadataObservation] @go(Metadata,[]MetadataObservation)

	// Method name to match from the request. If you specify a name, you must also specify a service_name.
	methodName?: null | string @go(MethodName,*string)

	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Fully qualified domain name for the service to match from the request.
	serviceName?: null | string @go(ServiceName,*string)
}

#GRPCRouteMatchParameters: {
	// Data to match from the gRPC request.
	// +kubebuilder:validation:Optional
	metadata?: [...#MetadataParameters] @go(Metadata,[]MetadataParameters)

	// Method name to match from the request. If you specify a name, you must also specify a service_name.
	// +kubebuilder:validation:Optional
	methodName?: null | string @go(MethodName,*string)

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	prefix?: null | string @go(Prefix,*string)

	// Fully qualified domain name for the service to match from the request.
	// +kubebuilder:validation:Optional
	serviceName?: null | string @go(ServiceName,*string)
}

#HTTPRouteActionWeightedTargetInitParameters: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#HTTPRouteActionWeightedTargetObservation: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#HTTPRouteActionWeightedTargetParameters: {
	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.VirtualNode
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	virtualNode?: null | string @go(VirtualNode,*string)

	// Reference to a VirtualNode in appmesh to populate virtualNode.
	// +kubebuilder:validation:Optional
	virtualNodeRef?: null | v1.#Reference @go(VirtualNodeRef,*v1.Reference)

	// Selector for a VirtualNode in appmesh to populate virtualNode.
	// +kubebuilder:validation:Optional
	virtualNodeSelector?: null | v1.#Selector @go(VirtualNodeSelector,*v1.Selector)

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Optional
	weight?: null | float64 @go(Weight,*float64)
}

#HTTPRouteMatchHeaderInitParameters: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	match?: [...#HTTPRouteMatchHeaderMatchInitParameters] @go(Match,[]HTTPRouteMatchHeaderMatchInitParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#HTTPRouteMatchHeaderMatchInitParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	range?: [...#MatchHeaderMatchRangeInitParameters] @go(Range,[]MatchHeaderMatchRangeInitParameters)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	suffix?: null | string @go(Suffix,*string)
}

#HTTPRouteMatchHeaderMatchObservation: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	range?: [...#MatchHeaderMatchRangeObservation] @go(Range,[]MatchHeaderMatchRangeObservation)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	suffix?: null | string @go(Suffix,*string)
}

#HTTPRouteMatchHeaderMatchParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	// +kubebuilder:validation:Optional
	range?: [...#MatchHeaderMatchRangeParameters] @go(Range,[]MatchHeaderMatchRangeParameters)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	suffix?: null | string @go(Suffix,*string)
}

#HTTPRouteMatchHeaderObservation: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	match?: [...#HTTPRouteMatchHeaderMatchObservation] @go(Match,[]HTTPRouteMatchHeaderMatchObservation)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#HTTPRouteMatchHeaderParameters: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	// +kubebuilder:validation:Optional
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#HTTPRouteMatchHeaderMatchParameters] @go(Match,[]HTTPRouteMatchHeaderMatchParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)
}

#HTTPRouteMatchPathInitParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)
}

#HTTPRouteMatchPathObservation: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)
}

#HTTPRouteMatchPathParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	regex?: null | string @go(Regex,*string)
}

#HTTPRouteMatchQueryParameterInitParameters: {
	// Criteria for determining an gRPC request match.
	match?: [...#HTTPRouteMatchQueryParameterMatchInitParameters] @go(Match,[]HTTPRouteMatchQueryParameterMatchInitParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#HTTPRouteMatchQueryParameterMatchInitParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)
}

#HTTPRouteMatchQueryParameterMatchObservation: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)
}

#HTTPRouteMatchQueryParameterMatchParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	exact?: null | string @go(Exact,*string)
}

#HTTPRouteMatchQueryParameterObservation: {
	// Criteria for determining an gRPC request match.
	match?: [...#HTTPRouteMatchQueryParameterMatchObservation] @go(Match,[]HTTPRouteMatchQueryParameterMatchObservation)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#HTTPRouteMatchQueryParameterParameters: {
	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#HTTPRouteMatchQueryParameterMatchParameters] @go(Match,[]HTTPRouteMatchQueryParameterMatchParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)
}

#HTTPRouteRetryPolicyInitParameters: {
	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	perRetryTimeout?: [...#HTTPRouteRetryPolicyPerRetryTimeoutInitParameters] @go(PerRetryTimeout,[]HTTPRouteRetryPolicyPerRetryTimeoutInitParameters)

	// List of TCP retry events. The only valid value is connection-error.
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#HTTPRouteRetryPolicyObservation: {
	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	perRetryTimeout?: [...#HTTPRouteRetryPolicyPerRetryTimeoutObservation] @go(PerRetryTimeout,[]HTTPRouteRetryPolicyPerRetryTimeoutObservation)

	// List of TCP retry events. The only valid value is connection-error.
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#HTTPRouteRetryPolicyParameters: {
	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	// +kubebuilder:validation:Optional
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	// +kubebuilder:validation:Optional
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	// +kubebuilder:validation:Optional
	perRetryTimeout: [...#HTTPRouteRetryPolicyPerRetryTimeoutParameters] @go(PerRetryTimeout,[]HTTPRouteRetryPolicyPerRetryTimeoutParameters)

	// List of TCP retry events. The only valid value is connection-error.
	// +kubebuilder:validation:Optional
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#HTTPRouteRetryPolicyPerRetryTimeoutInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteRetryPolicyPerRetryTimeoutObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteRetryPolicyPerRetryTimeoutParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteTimeoutIdleInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteTimeoutIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteTimeoutIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteTimeoutInitParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#HTTPRouteTimeoutIdleInitParameters] @go(Idle,[]HTTPRouteTimeoutIdleInitParameters)

	// Per request timeout.
	perRequest?: [...#HTTPRouteTimeoutPerRequestInitParameters] @go(PerRequest,[]HTTPRouteTimeoutPerRequestInitParameters)
}

#HTTPRouteTimeoutObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#HTTPRouteTimeoutIdleObservation] @go(Idle,[]HTTPRouteTimeoutIdleObservation)

	// Per request timeout.
	perRequest?: [...#HTTPRouteTimeoutPerRequestObservation] @go(PerRequest,[]HTTPRouteTimeoutPerRequestObservation)
}

#HTTPRouteTimeoutParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#HTTPRouteTimeoutIdleParameters] @go(Idle,[]HTTPRouteTimeoutIdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#HTTPRouteTimeoutPerRequestParameters] @go(PerRequest,[]HTTPRouteTimeoutPerRequestParameters)
}

#HTTPRouteTimeoutPerRequestInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteTimeoutPerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteTimeoutPerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#HeaderMatchRangeInitParameters: {
	// End of the range.
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	start?: null | float64 @go(Start,*float64)
}

#HeaderMatchRangeObservation: {
	// End of the range.
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	start?: null | float64 @go(Start,*float64)
}

#HeaderMatchRangeParameters: {
	// End of the range.
	// +kubebuilder:validation:Optional
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	// +kubebuilder:validation:Optional
	start?: null | float64 @go(Start,*float64)
}

#Http2RouteMatchHeaderInitParameters: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	match?: [...#Http2RouteMatchHeaderMatchInitParameters] @go(Match,[]Http2RouteMatchHeaderMatchInitParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#Http2RouteMatchHeaderMatchInitParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	range?: [...#HeaderMatchRangeInitParameters] @go(Range,[]HeaderMatchRangeInitParameters)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	suffix?: null | string @go(Suffix,*string)
}

#Http2RouteMatchHeaderMatchObservation: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	range?: [...#HeaderMatchRangeObservation] @go(Range,[]HeaderMatchRangeObservation)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	suffix?: null | string @go(Suffix,*string)
}

#Http2RouteMatchHeaderMatchParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	// +kubebuilder:validation:Optional
	range?: [...#HeaderMatchRangeParameters] @go(Range,[]HeaderMatchRangeParameters)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	suffix?: null | string @go(Suffix,*string)
}

#Http2RouteMatchHeaderObservation: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	match?: [...#Http2RouteMatchHeaderMatchObservation] @go(Match,[]Http2RouteMatchHeaderMatchObservation)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#Http2RouteMatchHeaderParameters: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	// +kubebuilder:validation:Optional
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#Http2RouteMatchHeaderMatchParameters] @go(Match,[]Http2RouteMatchHeaderMatchParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)
}

#Http2RouteMatchPathInitParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)
}

#Http2RouteMatchPathObservation: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)
}

#Http2RouteMatchPathParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	regex?: null | string @go(Regex,*string)
}

#Http2RouteMatchQueryParameterInitParameters: {
	// Criteria for determining an gRPC request match.
	match?: [...#Http2RouteMatchQueryParameterMatchInitParameters] @go(Match,[]Http2RouteMatchQueryParameterMatchInitParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#Http2RouteMatchQueryParameterMatchInitParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)
}

#Http2RouteMatchQueryParameterMatchObservation: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)
}

#Http2RouteMatchQueryParameterMatchParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	exact?: null | string @go(Exact,*string)
}

#Http2RouteMatchQueryParameterObservation: {
	// Criteria for determining an gRPC request match.
	match?: [...#Http2RouteMatchQueryParameterMatchObservation] @go(Match,[]Http2RouteMatchQueryParameterMatchObservation)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#Http2RouteMatchQueryParameterParameters: {
	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#Http2RouteMatchQueryParameterMatchParameters] @go(Match,[]Http2RouteMatchQueryParameterMatchParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)
}

#Http2RouteRetryPolicyInitParameters: {
	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	perRetryTimeout?: [...#RetryPolicyPerRetryTimeoutInitParameters] @go(PerRetryTimeout,[]RetryPolicyPerRetryTimeoutInitParameters)

	// List of TCP retry events. The only valid value is connection-error.
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#Http2RouteRetryPolicyObservation: {
	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	perRetryTimeout?: [...#RetryPolicyPerRetryTimeoutObservation] @go(PerRetryTimeout,[]RetryPolicyPerRetryTimeoutObservation)

	// List of TCP retry events. The only valid value is connection-error.
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#Http2RouteRetryPolicyParameters: {
	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	// +kubebuilder:validation:Optional
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	// +kubebuilder:validation:Optional
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	// +kubebuilder:validation:Optional
	perRetryTimeout: [...#RetryPolicyPerRetryTimeoutParameters] @go(PerRetryTimeout,[]RetryPolicyPerRetryTimeoutParameters)

	// List of TCP retry events. The only valid value is connection-error.
	// +kubebuilder:validation:Optional
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#Http2RouteTimeoutInitParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#TimeoutIdleInitParameters] @go(Idle,[]TimeoutIdleInitParameters)

	// Per request timeout.
	perRequest?: [...#TimeoutPerRequestInitParameters] @go(PerRequest,[]TimeoutPerRequestInitParameters)
}

#Http2RouteTimeoutObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#TimeoutIdleObservation] @go(Idle,[]TimeoutIdleObservation)

	// Per request timeout.
	perRequest?: [...#TimeoutPerRequestObservation] @go(PerRequest,[]TimeoutPerRequestObservation)
}

#Http2RouteTimeoutParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#TimeoutIdleParameters] @go(Idle,[]TimeoutIdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#TimeoutPerRequestParameters] @go(PerRequest,[]TimeoutPerRequestParameters)
}

#IdleInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#IdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#IdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#MatchHeaderMatchRangeInitParameters: {
	// End of the range.
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	start?: null | float64 @go(Start,*float64)
}

#MatchHeaderMatchRangeObservation: {
	// End of the range.
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	start?: null | float64 @go(Start,*float64)
}

#MatchHeaderMatchRangeParameters: {
	// End of the range.
	// +kubebuilder:validation:Optional
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	// +kubebuilder:validation:Optional
	start?: null | float64 @go(Start,*float64)
}

#MetadataInitParameters: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	match?: [...#MetadataMatchInitParameters] @go(Match,[]MetadataMatchInitParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#MetadataMatchInitParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	range?: [...#MetadataMatchRangeInitParameters] @go(Range,[]MetadataMatchRangeInitParameters)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	suffix?: null | string @go(Suffix,*string)
}

#MetadataMatchObservation: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	range?: [...#MetadataMatchRangeObservation] @go(Range,[]MetadataMatchRangeObservation)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	suffix?: null | string @go(Suffix,*string)
}

#MetadataMatchParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	// +kubebuilder:validation:Optional
	range?: [...#MetadataMatchRangeParameters] @go(Range,[]MetadataMatchRangeParameters)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	suffix?: null | string @go(Suffix,*string)
}

#MetadataMatchRangeInitParameters: {
	// End of the range.
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	start?: null | float64 @go(Start,*float64)
}

#MetadataMatchRangeObservation: {
	// End of the range.
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	start?: null | float64 @go(Start,*float64)
}

#MetadataMatchRangeParameters: {
	// End of the range.
	// +kubebuilder:validation:Optional
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	// +kubebuilder:validation:Optional
	start?: null | float64 @go(Start,*float64)
}

#MetadataObservation: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	match?: [...#MetadataMatchObservation] @go(Match,[]MetadataMatchObservation)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#MetadataParameters: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	// +kubebuilder:validation:Optional
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#MetadataMatchParameters] @go(Match,[]MetadataMatchParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)
}

#PerRequestInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#PerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#PerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#PerRetryTimeoutInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#PerRetryTimeoutObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#PerRetryTimeoutParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#RetryPolicyInitParameters: {
	// List of gRPC retry events.
	// Valid values: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
	grpcRetryEvents?: [...null | string] @go(GRPCRetryEvents,[]*string)

	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	perRetryTimeout?: [...#PerRetryTimeoutInitParameters] @go(PerRetryTimeout,[]PerRetryTimeoutInitParameters)

	// List of TCP retry events. The only valid value is connection-error.
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#RetryPolicyObservation: {
	// List of gRPC retry events.
	// Valid values: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
	grpcRetryEvents?: [...null | string] @go(GRPCRetryEvents,[]*string)

	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	perRetryTimeout?: [...#PerRetryTimeoutObservation] @go(PerRetryTimeout,[]PerRetryTimeoutObservation)

	// List of TCP retry events. The only valid value is connection-error.
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#RetryPolicyParameters: {
	// List of gRPC retry events.
	// Valid values: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
	// +kubebuilder:validation:Optional
	grpcRetryEvents?: [...null | string] @go(GRPCRetryEvents,[]*string)

	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	// +kubebuilder:validation:Optional
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	// +kubebuilder:validation:Optional
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	// +kubebuilder:validation:Optional
	perRetryTimeout: [...#PerRetryTimeoutParameters] @go(PerRetryTimeout,[]PerRetryTimeoutParameters)

	// List of TCP retry events. The only valid value is connection-error.
	// +kubebuilder:validation:Optional
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#RetryPolicyPerRetryTimeoutInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#RetryPolicyPerRetryTimeoutObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#RetryPolicyPerRetryTimeoutParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#RouteInitParameters: {
	// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
	meshOwner?: null | string @go(MeshOwner,*string)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)

	// Route specification to apply.
	spec?: [...#RouteSpecInitParameters] @go(Spec,[]RouteSpecInitParameters)

	// Key-value map of resource tags.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)
}

#RouteObservation: {
	// ARN of the route.
	arn?: null | string @go(Arn,*string)

	// Creation date of the route.
	createdDate?: null | string @go(CreatedDate,*string)

	// ID of the route.
	id?: null | string @go(ID,*string)

	// Last update date of the route.
	lastUpdatedDate?: null | string @go(LastUpdatedDate,*string)

	// Name of the service mesh in which to create the route. Must be between 1 and 255 characters in length.
	meshName?: null | string @go(MeshName,*string)

	// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
	meshOwner?: null | string @go(MeshOwner,*string)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)

	// Resource owner's AWS account ID.
	resourceOwner?: null | string @go(ResourceOwner,*string)

	// Route specification to apply.
	spec?: [...#RouteSpecObservation] @go(Spec,[]RouteSpecObservation)

	// Key-value map of resource tags.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)

	// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
	tagsAll?: {[string]: null | string} @go(TagsAll,map[string]*string)

	// Name of the virtual router in which to create the route. Must be between 1 and 255 characters in length.
	virtualRouterName?: null | string @go(VirtualRouterName,*string)
}

#RouteParameters: {
	// Name of the service mesh in which to create the route. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.Mesh
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	meshName?: null | string @go(MeshName,*string)

	// Reference to a Mesh in appmesh to populate meshName.
	// +kubebuilder:validation:Optional
	meshNameRef?: null | v1.#Reference @go(MeshNameRef,*v1.Reference)

	// Selector for a Mesh in appmesh to populate meshName.
	// +kubebuilder:validation:Optional
	meshNameSelector?: null | v1.#Selector @go(MeshNameSelector,*v1.Selector)

	// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
	// +kubebuilder:validation:Optional
	meshOwner?: null | string @go(MeshOwner,*string)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	region?: null | string @go(Region,*string)

	// Route specification to apply.
	// +kubebuilder:validation:Optional
	spec?: [...#RouteSpecParameters] @go(Spec,[]RouteSpecParameters)

	// Key-value map of resource tags.
	// +kubebuilder:validation:Optional
	tags?: {[string]: null | string} @go(Tags,map[string]*string)

	// Name of the virtual router in which to create the route. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.VirtualRouter
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	virtualRouterName?: null | string @go(VirtualRouterName,*string)

	// Reference to a VirtualRouter in appmesh to populate virtualRouterName.
	// +kubebuilder:validation:Optional
	virtualRouterNameRef?: null | v1.#Reference @go(VirtualRouterNameRef,*v1.Reference)

	// Selector for a VirtualRouter in appmesh to populate virtualRouterName.
	// +kubebuilder:validation:Optional
	virtualRouterNameSelector?: null | v1.#Selector @go(VirtualRouterNameSelector,*v1.Selector)
}

#RouteSpecInitParameters: {
	// GRPC routing information for the route.
	grpcRoute?: [...#SpecGRPCRouteInitParameters] @go(GRPCRoute,[]SpecGRPCRouteInitParameters)

	// HTTP routing information for the route.
	httpRoute?: [...#SpecHTTPRouteInitParameters] @go(HTTPRoute,[]SpecHTTPRouteInitParameters)

	// HTTP/2 routing information for the route.
	http2Route?: [...#SpecHttp2RouteInitParameters] @go(Http2Route,[]SpecHttp2RouteInitParameters)

	// Priority for the route, between 0 and 1000.
	// Routes are matched based on the specified value, where 0 is the highest priority.
	priority?: null | float64 @go(Priority,*float64)

	// TCP routing information for the route.
	tcpRoute?: [...#TCPRouteInitParameters] @go(TCPRoute,[]TCPRouteInitParameters)
}

#RouteSpecObservation: {
	// GRPC routing information for the route.
	grpcRoute?: [...#SpecGRPCRouteObservation] @go(GRPCRoute,[]SpecGRPCRouteObservation)

	// HTTP routing information for the route.
	httpRoute?: [...#SpecHTTPRouteObservation] @go(HTTPRoute,[]SpecHTTPRouteObservation)

	// HTTP/2 routing information for the route.
	http2Route?: [...#SpecHttp2RouteObservation] @go(Http2Route,[]SpecHttp2RouteObservation)

	// Priority for the route, between 0 and 1000.
	// Routes are matched based on the specified value, where 0 is the highest priority.
	priority?: null | float64 @go(Priority,*float64)

	// TCP routing information for the route.
	tcpRoute?: [...#TCPRouteObservation] @go(TCPRoute,[]TCPRouteObservation)
}

#RouteSpecParameters: {
	// GRPC routing information for the route.
	// +kubebuilder:validation:Optional
	grpcRoute?: [...#SpecGRPCRouteParameters] @go(GRPCRoute,[]SpecGRPCRouteParameters)

	// HTTP routing information for the route.
	// +kubebuilder:validation:Optional
	httpRoute?: [...#SpecHTTPRouteParameters] @go(HTTPRoute,[]SpecHTTPRouteParameters)

	// HTTP/2 routing information for the route.
	// +kubebuilder:validation:Optional
	http2Route?: [...#SpecHttp2RouteParameters] @go(Http2Route,[]SpecHttp2RouteParameters)

	// Priority for the route, between 0 and 1000.
	// Routes are matched based on the specified value, where 0 is the highest priority.
	// +kubebuilder:validation:Optional
	priority?: null | float64 @go(Priority,*float64)

	// TCP routing information for the route.
	// +kubebuilder:validation:Optional
	tcpRoute?: [...#TCPRouteParameters] @go(TCPRoute,[]TCPRouteParameters)
}

#SpecGRPCRouteInitParameters: {
	// Action to take if a match is determined.
	action?: [...#GRPCRouteActionInitParameters] @go(Action,[]GRPCRouteActionInitParameters)

	// Criteria for determining an gRPC request match.
	match?: [...#GRPCRouteMatchInitParameters] @go(Match,[]GRPCRouteMatchInitParameters)

	// Retry policy.
	retryPolicy?: [...#RetryPolicyInitParameters] @go(RetryPolicy,[]RetryPolicyInitParameters)

	// Types of timeouts.
	timeout?: [...#TimeoutInitParameters] @go(Timeout,[]TimeoutInitParameters)
}

#SpecGRPCRouteObservation: {
	// Action to take if a match is determined.
	action?: [...#GRPCRouteActionObservation] @go(Action,[]GRPCRouteActionObservation)

	// Criteria for determining an gRPC request match.
	match?: [...#GRPCRouteMatchObservation] @go(Match,[]GRPCRouteMatchObservation)

	// Retry policy.
	retryPolicy?: [...#RetryPolicyObservation] @go(RetryPolicy,[]RetryPolicyObservation)

	// Types of timeouts.
	timeout?: [...#TimeoutObservation] @go(Timeout,[]TimeoutObservation)
}

#SpecGRPCRouteParameters: {
	// Action to take if a match is determined.
	// +kubebuilder:validation:Optional
	action: [...#GRPCRouteActionParameters] @go(Action,[]GRPCRouteActionParameters)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#GRPCRouteMatchParameters] @go(Match,[]GRPCRouteMatchParameters)

	// Retry policy.
	// +kubebuilder:validation:Optional
	retryPolicy?: [...#RetryPolicyParameters] @go(RetryPolicy,[]RetryPolicyParameters)

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	timeout?: [...#TimeoutParameters] @go(Timeout,[]TimeoutParameters)
}

#SpecHTTPRouteActionInitParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#HTTPRouteActionWeightedTargetInitParameters] @go(WeightedTarget,[]HTTPRouteActionWeightedTargetInitParameters)
}

#SpecHTTPRouteActionObservation: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#HTTPRouteActionWeightedTargetObservation] @go(WeightedTarget,[]HTTPRouteActionWeightedTargetObservation)
}

#SpecHTTPRouteActionParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Optional
	weightedTarget: [...#HTTPRouteActionWeightedTargetParameters] @go(WeightedTarget,[]HTTPRouteActionWeightedTargetParameters)
}

#SpecHTTPRouteInitParameters: {
	// Action to take if a match is determined.
	action?: [...#SpecHTTPRouteActionInitParameters] @go(Action,[]SpecHTTPRouteActionInitParameters)

	// Criteria for determining an gRPC request match.
	match?: [...#SpecHTTPRouteMatchInitParameters] @go(Match,[]SpecHTTPRouteMatchInitParameters)

	// Retry policy.
	retryPolicy?: [...#HTTPRouteRetryPolicyInitParameters] @go(RetryPolicy,[]HTTPRouteRetryPolicyInitParameters)

	// Types of timeouts.
	timeout?: [...#HTTPRouteTimeoutInitParameters] @go(Timeout,[]HTTPRouteTimeoutInitParameters)
}

#SpecHTTPRouteMatchInitParameters: {
	// Client request headers to match on.
	header?: [...#HTTPRouteMatchHeaderInitParameters] @go(Header,[]HTTPRouteMatchHeaderInitParameters)

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	method?: null | string @go(Method,*string)

	// Client request path to match on.
	path?: [...#HTTPRouteMatchPathInitParameters] @go(Path,[]HTTPRouteMatchPathInitParameters)

	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Client request query parameters to match on.
	queryParameter?: [...#HTTPRouteMatchQueryParameterInitParameters] @go(QueryParameter,[]HTTPRouteMatchQueryParameterInitParameters)

	// Client request header scheme to match on. Valid values: http, https.
	scheme?: null | string @go(Scheme,*string)
}

#SpecHTTPRouteMatchObservation: {
	// Client request headers to match on.
	header?: [...#HTTPRouteMatchHeaderObservation] @go(Header,[]HTTPRouteMatchHeaderObservation)

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	method?: null | string @go(Method,*string)

	// Client request path to match on.
	path?: [...#HTTPRouteMatchPathObservation] @go(Path,[]HTTPRouteMatchPathObservation)

	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Client request query parameters to match on.
	queryParameter?: [...#HTTPRouteMatchQueryParameterObservation] @go(QueryParameter,[]HTTPRouteMatchQueryParameterObservation)

	// Client request header scheme to match on. Valid values: http, https.
	scheme?: null | string @go(Scheme,*string)
}

#SpecHTTPRouteMatchParameters: {
	// Client request headers to match on.
	// +kubebuilder:validation:Optional
	header?: [...#HTTPRouteMatchHeaderParameters] @go(Header,[]HTTPRouteMatchHeaderParameters)

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	// +kubebuilder:validation:Optional
	method?: null | string @go(Method,*string)

	// Client request path to match on.
	// +kubebuilder:validation:Optional
	path?: [...#HTTPRouteMatchPathParameters] @go(Path,[]HTTPRouteMatchPathParameters)

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	prefix?: null | string @go(Prefix,*string)

	// Client request query parameters to match on.
	// +kubebuilder:validation:Optional
	queryParameter?: [...#HTTPRouteMatchQueryParameterParameters] @go(QueryParameter,[]HTTPRouteMatchQueryParameterParameters)

	// Client request header scheme to match on. Valid values: http, https.
	// +kubebuilder:validation:Optional
	scheme?: null | string @go(Scheme,*string)
}

#SpecHTTPRouteObservation: {
	// Action to take if a match is determined.
	action?: [...#SpecHTTPRouteActionObservation] @go(Action,[]SpecHTTPRouteActionObservation)

	// Criteria for determining an gRPC request match.
	match?: [...#SpecHTTPRouteMatchObservation] @go(Match,[]SpecHTTPRouteMatchObservation)

	// Retry policy.
	retryPolicy?: [...#HTTPRouteRetryPolicyObservation] @go(RetryPolicy,[]HTTPRouteRetryPolicyObservation)

	// Types of timeouts.
	timeout?: [...#HTTPRouteTimeoutObservation] @go(Timeout,[]HTTPRouteTimeoutObservation)
}

#SpecHTTPRouteParameters: {
	// Action to take if a match is determined.
	// +kubebuilder:validation:Optional
	action: [...#SpecHTTPRouteActionParameters] @go(Action,[]SpecHTTPRouteActionParameters)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match: [...#SpecHTTPRouteMatchParameters] @go(Match,[]SpecHTTPRouteMatchParameters)

	// Retry policy.
	// +kubebuilder:validation:Optional
	retryPolicy?: [...#HTTPRouteRetryPolicyParameters] @go(RetryPolicy,[]HTTPRouteRetryPolicyParameters)

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	timeout?: [...#HTTPRouteTimeoutParameters] @go(Timeout,[]HTTPRouteTimeoutParameters)
}

#SpecHttp2RouteActionInitParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#ActionWeightedTargetInitParameters] @go(WeightedTarget,[]ActionWeightedTargetInitParameters)
}

#SpecHttp2RouteActionObservation: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#ActionWeightedTargetObservation] @go(WeightedTarget,[]ActionWeightedTargetObservation)
}

#SpecHttp2RouteActionParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Optional
	weightedTarget: [...#ActionWeightedTargetParameters] @go(WeightedTarget,[]ActionWeightedTargetParameters)
}

#SpecHttp2RouteInitParameters: {
	// Action to take if a match is determined.
	action?: [...#SpecHttp2RouteActionInitParameters] @go(Action,[]SpecHttp2RouteActionInitParameters)

	// Criteria for determining an gRPC request match.
	match?: [...#SpecHttp2RouteMatchInitParameters] @go(Match,[]SpecHttp2RouteMatchInitParameters)

	// Retry policy.
	retryPolicy?: [...#Http2RouteRetryPolicyInitParameters] @go(RetryPolicy,[]Http2RouteRetryPolicyInitParameters)

	// Types of timeouts.
	timeout?: [...#Http2RouteTimeoutInitParameters] @go(Timeout,[]Http2RouteTimeoutInitParameters)
}

#SpecHttp2RouteMatchInitParameters: {
	// Client request headers to match on.
	header?: [...#Http2RouteMatchHeaderInitParameters] @go(Header,[]Http2RouteMatchHeaderInitParameters)

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	method?: null | string @go(Method,*string)

	// Client request path to match on.
	path?: [...#Http2RouteMatchPathInitParameters] @go(Path,[]Http2RouteMatchPathInitParameters)

	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Client request query parameters to match on.
	queryParameter?: [...#Http2RouteMatchQueryParameterInitParameters] @go(QueryParameter,[]Http2RouteMatchQueryParameterInitParameters)

	// Client request header scheme to match on. Valid values: http, https.
	scheme?: null | string @go(Scheme,*string)
}

#SpecHttp2RouteMatchObservation: {
	// Client request headers to match on.
	header?: [...#Http2RouteMatchHeaderObservation] @go(Header,[]Http2RouteMatchHeaderObservation)

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	method?: null | string @go(Method,*string)

	// Client request path to match on.
	path?: [...#Http2RouteMatchPathObservation] @go(Path,[]Http2RouteMatchPathObservation)

	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Client request query parameters to match on.
	queryParameter?: [...#Http2RouteMatchQueryParameterObservation] @go(QueryParameter,[]Http2RouteMatchQueryParameterObservation)

	// Client request header scheme to match on. Valid values: http, https.
	scheme?: null | string @go(Scheme,*string)
}

#SpecHttp2RouteMatchParameters: {
	// Client request headers to match on.
	// +kubebuilder:validation:Optional
	header?: [...#Http2RouteMatchHeaderParameters] @go(Header,[]Http2RouteMatchHeaderParameters)

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	// +kubebuilder:validation:Optional
	method?: null | string @go(Method,*string)

	// Client request path to match on.
	// +kubebuilder:validation:Optional
	path?: [...#Http2RouteMatchPathParameters] @go(Path,[]Http2RouteMatchPathParameters)

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	prefix?: null | string @go(Prefix,*string)

	// Client request query parameters to match on.
	// +kubebuilder:validation:Optional
	queryParameter?: [...#Http2RouteMatchQueryParameterParameters] @go(QueryParameter,[]Http2RouteMatchQueryParameterParameters)

	// Client request header scheme to match on. Valid values: http, https.
	// +kubebuilder:validation:Optional
	scheme?: null | string @go(Scheme,*string)
}

#SpecHttp2RouteObservation: {
	// Action to take if a match is determined.
	action?: [...#SpecHttp2RouteActionObservation] @go(Action,[]SpecHttp2RouteActionObservation)

	// Criteria for determining an gRPC request match.
	match?: [...#SpecHttp2RouteMatchObservation] @go(Match,[]SpecHttp2RouteMatchObservation)

	// Retry policy.
	retryPolicy?: [...#Http2RouteRetryPolicyObservation] @go(RetryPolicy,[]Http2RouteRetryPolicyObservation)

	// Types of timeouts.
	timeout?: [...#Http2RouteTimeoutObservation] @go(Timeout,[]Http2RouteTimeoutObservation)
}

#SpecHttp2RouteParameters: {
	// Action to take if a match is determined.
	// +kubebuilder:validation:Optional
	action: [...#SpecHttp2RouteActionParameters] @go(Action,[]SpecHttp2RouteActionParameters)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match: [...#SpecHttp2RouteMatchParameters] @go(Match,[]SpecHttp2RouteMatchParameters)

	// Retry policy.
	// +kubebuilder:validation:Optional
	retryPolicy?: [...#Http2RouteRetryPolicyParameters] @go(RetryPolicy,[]Http2RouteRetryPolicyParameters)

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	timeout?: [...#Http2RouteTimeoutParameters] @go(Timeout,[]Http2RouteTimeoutParameters)
}

#TCPRouteActionInitParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#TCPRouteActionWeightedTargetInitParameters] @go(WeightedTarget,[]TCPRouteActionWeightedTargetInitParameters)
}

#TCPRouteActionObservation: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#TCPRouteActionWeightedTargetObservation] @go(WeightedTarget,[]TCPRouteActionWeightedTargetObservation)
}

#TCPRouteActionParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Optional
	weightedTarget: [...#TCPRouteActionWeightedTargetParameters] @go(WeightedTarget,[]TCPRouteActionWeightedTargetParameters)
}

#TCPRouteActionWeightedTargetInitParameters: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#TCPRouteActionWeightedTargetObservation: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#TCPRouteActionWeightedTargetParameters: {
	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.VirtualNode
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	virtualNode?: null | string @go(VirtualNode,*string)

	// Reference to a VirtualNode in appmesh to populate virtualNode.
	// +kubebuilder:validation:Optional
	virtualNodeRef?: null | v1.#Reference @go(VirtualNodeRef,*v1.Reference)

	// Selector for a VirtualNode in appmesh to populate virtualNode.
	// +kubebuilder:validation:Optional
	virtualNodeSelector?: null | v1.#Selector @go(VirtualNodeSelector,*v1.Selector)

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Optional
	weight?: null | float64 @go(Weight,*float64)
}

#TCPRouteInitParameters: {
	// Action to take if a match is determined.
	action?: [...#TCPRouteActionInitParameters] @go(Action,[]TCPRouteActionInitParameters)

	// Criteria for determining an gRPC request match.
	match?: [...#TCPRouteMatchInitParameters] @go(Match,[]TCPRouteMatchInitParameters)

	// Types of timeouts.
	timeout?: [...#TCPRouteTimeoutInitParameters] @go(Timeout,[]TCPRouteTimeoutInitParameters)
}

#TCPRouteMatchInitParameters: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)
}

#TCPRouteMatchObservation: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)
}

#TCPRouteMatchParameters: {
	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)
}

#TCPRouteObservation: {
	// Action to take if a match is determined.
	action?: [...#TCPRouteActionObservation] @go(Action,[]TCPRouteActionObservation)

	// Criteria for determining an gRPC request match.
	match?: [...#TCPRouteMatchObservation] @go(Match,[]TCPRouteMatchObservation)

	// Types of timeouts.
	timeout?: [...#TCPRouteTimeoutObservation] @go(Timeout,[]TCPRouteTimeoutObservation)
}

#TCPRouteParameters: {
	// Action to take if a match is determined.
	// +kubebuilder:validation:Optional
	action: [...#TCPRouteActionParameters] @go(Action,[]TCPRouteActionParameters)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#TCPRouteMatchParameters] @go(Match,[]TCPRouteMatchParameters)

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	timeout?: [...#TCPRouteTimeoutParameters] @go(Timeout,[]TCPRouteTimeoutParameters)
}

#TCPRouteTimeoutIdleInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#TCPRouteTimeoutIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#TCPRouteTimeoutIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#TCPRouteTimeoutInitParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#TCPRouteTimeoutIdleInitParameters] @go(Idle,[]TCPRouteTimeoutIdleInitParameters)
}

#TCPRouteTimeoutObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#TCPRouteTimeoutIdleObservation] @go(Idle,[]TCPRouteTimeoutIdleObservation)
}

#TCPRouteTimeoutParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#TCPRouteTimeoutIdleParameters] @go(Idle,[]TCPRouteTimeoutIdleParameters)
}

#TimeoutIdleInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#TimeoutIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#TimeoutIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#TimeoutInitParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#IdleInitParameters] @go(Idle,[]IdleInitParameters)

	// Per request timeout.
	perRequest?: [...#PerRequestInitParameters] @go(PerRequest,[]PerRequestInitParameters)
}

#TimeoutObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#IdleObservation] @go(Idle,[]IdleObservation)

	// Per request timeout.
	perRequest?: [...#PerRequestObservation] @go(PerRequest,[]PerRequestObservation)
}

#TimeoutParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#IdleParameters] @go(Idle,[]IdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#PerRequestParameters] @go(PerRequest,[]PerRequestParameters)
}

#TimeoutPerRequestInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#TimeoutPerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#TimeoutPerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#WeightedTargetInitParameters: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#WeightedTargetObservation: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#WeightedTargetParameters: {
	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Optional
	weight?: null | float64 @go(Weight,*float64)
}

// RouteSpec defines the desired state of Route
#RouteSpec: {
	v1.#ResourceSpec
	forProvider: #RouteParameters @go(ForProvider)

	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #RouteInitParameters @go(InitProvider)
}

// RouteStatus defines the observed state of Route.
#RouteStatus: {
	v1.#ResourceStatus
	atProvider?: #RouteObservation @go(AtProvider)
}

// Route is the Schema for the Routes API. Provides an AWS App Mesh route resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
#Route: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.spec) || (has(self.initProvider) && has(self.initProvider.spec))",message="spec.forProvider.spec is a required parameter"
	spec:    #RouteSpec   @go(Spec)
	status?: #RouteStatus @go(Status)
}

// RouteList contains a list of Routes
#RouteList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#Route] @go(Items,[]Route)
}
