// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-aws/apis/appmesh/v1beta1

package v1beta1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#AwsCloudMapInitParameters: {
	// String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
	attributes?: {[string]: null | string} @go(Attributes,map[string]*string)

	// attribute of the dns object to hostname.
	serviceName?: null | string @go(ServiceName,*string)
}

#AwsCloudMapObservation: {
	// String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
	attributes?: {[string]: null | string} @go(Attributes,map[string]*string)

	// Name of the AWS Cloud Map namespace to use.
	// Use the aws_service_discovery_http_namespace resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
	namespaceName?: null | string @go(NamespaceName,*string)

	// attribute of the dns object to hostname.
	serviceName?: null | string @go(ServiceName,*string)
}

#AwsCloudMapParameters: {
	// String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
	// +kubebuilder:validation:Optional
	attributes?: {[string]: null | string} @go(Attributes,map[string]*string)

	// Name of the AWS Cloud Map namespace to use.
	// Use the aws_service_discovery_http_namespace resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/servicediscovery/v1beta1.HTTPNamespace
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	namespaceName?: null | string @go(NamespaceName,*string)

	// Reference to a HTTPNamespace in servicediscovery to populate namespaceName.
	// +kubebuilder:validation:Optional
	namespaceNameRef?: null | v1.#Reference @go(NamespaceNameRef,*v1.Reference)

	// Selector for a HTTPNamespace in servicediscovery to populate namespaceName.
	// +kubebuilder:validation:Optional
	namespaceNameSelector?: null | v1.#Selector @go(NamespaceNameSelector,*v1.Selector)

	// attribute of the dns object to hostname.
	// +kubebuilder:validation:Optional
	serviceName?: null | string @go(ServiceName,*string)
}

#BackendDefaultsClientPolicyInitParameters: {
	// Transport Layer Security (TLS) client policy.
	tls?: [...#BackendDefaultsClientPolicyTLSInitParameters] @go(TLS,[]BackendDefaultsClientPolicyTLSInitParameters)
}

#BackendDefaultsClientPolicyObservation: {
	// Transport Layer Security (TLS) client policy.
	tls?: [...#BackendDefaultsClientPolicyTLSObservation] @go(TLS,[]BackendDefaultsClientPolicyTLSObservation)
}

#BackendDefaultsClientPolicyParameters: {
	// Transport Layer Security (TLS) client policy.
	// +kubebuilder:validation:Optional
	tls?: [...#BackendDefaultsClientPolicyTLSParameters] @go(TLS,[]BackendDefaultsClientPolicyTLSParameters)
}

#BackendDefaultsClientPolicyTLSCertificateInitParameters: {
	// Local file certificate.
	file?: [...#ClientPolicyTLSCertificateFileInitParameters] @go(File,[]ClientPolicyTLSCertificateFileInitParameters)

	// A Secret Discovery Service certificate.
	sds?: [...#ClientPolicyTLSCertificateSdsInitParameters] @go(Sds,[]ClientPolicyTLSCertificateSdsInitParameters)
}

#BackendDefaultsClientPolicyTLSCertificateObservation: {
	// Local file certificate.
	file?: [...#ClientPolicyTLSCertificateFileObservation] @go(File,[]ClientPolicyTLSCertificateFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#ClientPolicyTLSCertificateSdsObservation] @go(Sds,[]ClientPolicyTLSCertificateSdsObservation)
}

#BackendDefaultsClientPolicyTLSCertificateParameters: {
	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#ClientPolicyTLSCertificateFileParameters] @go(File,[]ClientPolicyTLSCertificateFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#ClientPolicyTLSCertificateSdsParameters] @go(Sds,[]ClientPolicyTLSCertificateSdsParameters)
}

#BackendDefaultsClientPolicyTLSInitParameters: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	certificate?: [...#BackendDefaultsClientPolicyTLSCertificateInitParameters] @go(Certificate,[]BackendDefaultsClientPolicyTLSCertificateInitParameters)

	// Whether the policy is enforced. Default is true.
	enforce?: null | bool @go(Enforce,*bool)

	// One or more ports that the policy is enforced for.
	ports?: [...null | float64] @go(Ports,[]*float64)

	// TLS validation context.
	validation?: [...#BackendDefaultsClientPolicyTLSValidationInitParameters] @go(Validation,[]BackendDefaultsClientPolicyTLSValidationInitParameters)
}

#BackendDefaultsClientPolicyTLSObservation: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	certificate?: [...#BackendDefaultsClientPolicyTLSCertificateObservation] @go(Certificate,[]BackendDefaultsClientPolicyTLSCertificateObservation)

	// Whether the policy is enforced. Default is true.
	enforce?: null | bool @go(Enforce,*bool)

	// One or more ports that the policy is enforced for.
	ports?: [...null | float64] @go(Ports,[]*float64)

	// TLS validation context.
	validation?: [...#BackendDefaultsClientPolicyTLSValidationObservation] @go(Validation,[]BackendDefaultsClientPolicyTLSValidationObservation)
}

#BackendDefaultsClientPolicyTLSParameters: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	// +kubebuilder:validation:Optional
	certificate?: [...#BackendDefaultsClientPolicyTLSCertificateParameters] @go(Certificate,[]BackendDefaultsClientPolicyTLSCertificateParameters)

	// Whether the policy is enforced. Default is true.
	// +kubebuilder:validation:Optional
	enforce?: null | bool @go(Enforce,*bool)

	// One or more ports that the policy is enforced for.
	// +kubebuilder:validation:Optional
	ports?: [...null | float64] @go(Ports,[]*float64)

	// TLS validation context.
	// +kubebuilder:validation:Optional
	validation: [...#BackendDefaultsClientPolicyTLSValidationParameters] @go(Validation,[]BackendDefaultsClientPolicyTLSValidationParameters)
}

#BackendDefaultsClientPolicyTLSValidationInitParameters: {
	// SANs for a TLS validation context.
	subjectAlternativeNames?: [...#ClientPolicyTLSValidationSubjectAlternativeNamesInitParameters] @go(SubjectAlternativeNames,[]ClientPolicyTLSValidationSubjectAlternativeNamesInitParameters)

	// TLS validation context trust.
	trust?: [...#ClientPolicyTLSValidationTrustInitParameters] @go(Trust,[]ClientPolicyTLSValidationTrustInitParameters)
}

#BackendDefaultsClientPolicyTLSValidationObservation: {
	// SANs for a TLS validation context.
	subjectAlternativeNames?: [...#ClientPolicyTLSValidationSubjectAlternativeNamesObservation] @go(SubjectAlternativeNames,[]ClientPolicyTLSValidationSubjectAlternativeNamesObservation)

	// TLS validation context trust.
	trust?: [...#ClientPolicyTLSValidationTrustObservation] @go(Trust,[]ClientPolicyTLSValidationTrustObservation)
}

#BackendDefaultsClientPolicyTLSValidationParameters: {
	// SANs for a TLS validation context.
	// +kubebuilder:validation:Optional
	subjectAlternativeNames?: [...#ClientPolicyTLSValidationSubjectAlternativeNamesParameters] @go(SubjectAlternativeNames,[]ClientPolicyTLSValidationSubjectAlternativeNamesParameters)

	// TLS validation context trust.
	// +kubebuilder:validation:Optional
	trust: [...#ClientPolicyTLSValidationTrustParameters] @go(Trust,[]ClientPolicyTLSValidationTrustParameters)
}

#BackendInitParameters: {
	// Virtual service to use as a backend for a virtual node.
	virtualService?: [...#BackendVirtualServiceInitParameters] @go(VirtualService,[]BackendVirtualServiceInitParameters)
}

#BackendObservation: {
	// Virtual service to use as a backend for a virtual node.
	virtualService?: [...#BackendVirtualServiceObservation] @go(VirtualService,[]BackendVirtualServiceObservation)
}

#BackendParameters: {
	// Virtual service to use as a backend for a virtual node.
	// +kubebuilder:validation:Optional
	virtualService: [...#BackendVirtualServiceParameters] @go(VirtualService,[]BackendVirtualServiceParameters)
}

#BackendVirtualServiceInitParameters: {
	// Client policy for the backend.
	clientPolicy?: [...#VirtualServiceClientPolicyInitParameters] @go(ClientPolicy,[]VirtualServiceClientPolicyInitParameters)

	// Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
	virtualServiceName?: null | string @go(VirtualServiceName,*string)
}

#BackendVirtualServiceObservation: {
	// Client policy for the backend.
	clientPolicy?: [...#VirtualServiceClientPolicyObservation] @go(ClientPolicy,[]VirtualServiceClientPolicyObservation)

	// Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
	virtualServiceName?: null | string @go(VirtualServiceName,*string)
}

#BackendVirtualServiceParameters: {
	// Client policy for the backend.
	// +kubebuilder:validation:Optional
	clientPolicy?: [...#VirtualServiceClientPolicyParameters] @go(ClientPolicy,[]VirtualServiceClientPolicyParameters)

	// Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	virtualServiceName?: null | string @go(VirtualServiceName,*string)
}

#BaseEjectionDurationInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#BaseEjectionDurationObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#BaseEjectionDurationParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#ClientPolicyTLSCertificateFileInitParameters: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	privateKey?: null | string @go(PrivateKey,*string)
}

#ClientPolicyTLSCertificateFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	privateKey?: null | string @go(PrivateKey,*string)
}

#ClientPolicyTLSCertificateFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Optional
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	// +kubebuilder:validation:Optional
	privateKey?: null | string @go(PrivateKey,*string)
}

#ClientPolicyTLSCertificateInitParameters: {
	// Local file certificate.
	file?: [...#TLSCertificateFileInitParameters] @go(File,[]TLSCertificateFileInitParameters)

	// A Secret Discovery Service certificate.
	sds?: [...#TLSCertificateSdsInitParameters] @go(Sds,[]TLSCertificateSdsInitParameters)
}

#ClientPolicyTLSCertificateObservation: {
	// Local file certificate.
	file?: [...#TLSCertificateFileObservation] @go(File,[]TLSCertificateFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#TLSCertificateSdsObservation] @go(Sds,[]TLSCertificateSdsObservation)
}

#ClientPolicyTLSCertificateParameters: {
	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#TLSCertificateFileParameters] @go(File,[]TLSCertificateFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#TLSCertificateSdsParameters] @go(Sds,[]TLSCertificateSdsParameters)
}

#ClientPolicyTLSCertificateSdsInitParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ClientPolicyTLSCertificateSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ClientPolicyTLSCertificateSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Optional
	secretName?: null | string @go(SecretName,*string)
}

#ClientPolicyTLSInitParameters: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	certificate?: [...#ClientPolicyTLSCertificateInitParameters] @go(Certificate,[]ClientPolicyTLSCertificateInitParameters)

	// Whether the policy is enforced. Default is true.
	enforce?: null | bool @go(Enforce,*bool)

	// One or more ports that the policy is enforced for.
	ports?: [...null | float64] @go(Ports,[]*float64)

	// TLS validation context.
	validation?: [...#ClientPolicyTLSValidationInitParameters] @go(Validation,[]ClientPolicyTLSValidationInitParameters)
}

#ClientPolicyTLSObservation: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	certificate?: [...#ClientPolicyTLSCertificateObservation] @go(Certificate,[]ClientPolicyTLSCertificateObservation)

	// Whether the policy is enforced. Default is true.
	enforce?: null | bool @go(Enforce,*bool)

	// One or more ports that the policy is enforced for.
	ports?: [...null | float64] @go(Ports,[]*float64)

	// TLS validation context.
	validation?: [...#ClientPolicyTLSValidationObservation] @go(Validation,[]ClientPolicyTLSValidationObservation)
}

#ClientPolicyTLSParameters: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	// +kubebuilder:validation:Optional
	certificate?: [...#ClientPolicyTLSCertificateParameters] @go(Certificate,[]ClientPolicyTLSCertificateParameters)

	// Whether the policy is enforced. Default is true.
	// +kubebuilder:validation:Optional
	enforce?: null | bool @go(Enforce,*bool)

	// One or more ports that the policy is enforced for.
	// +kubebuilder:validation:Optional
	ports?: [...null | float64] @go(Ports,[]*float64)

	// TLS validation context.
	// +kubebuilder:validation:Optional
	validation: [...#ClientPolicyTLSValidationParameters] @go(Validation,[]ClientPolicyTLSValidationParameters)
}

#ClientPolicyTLSValidationInitParameters: {
	// SANs for a TLS validation context.
	subjectAlternativeNames?: [...#TLSValidationSubjectAlternativeNamesInitParameters] @go(SubjectAlternativeNames,[]TLSValidationSubjectAlternativeNamesInitParameters)

	// TLS validation context trust.
	trust?: [...#TLSValidationTrustInitParameters] @go(Trust,[]TLSValidationTrustInitParameters)
}

#ClientPolicyTLSValidationObservation: {
	// SANs for a TLS validation context.
	subjectAlternativeNames?: [...#TLSValidationSubjectAlternativeNamesObservation] @go(SubjectAlternativeNames,[]TLSValidationSubjectAlternativeNamesObservation)

	// TLS validation context trust.
	trust?: [...#TLSValidationTrustObservation] @go(Trust,[]TLSValidationTrustObservation)
}

#ClientPolicyTLSValidationParameters: {
	// SANs for a TLS validation context.
	// +kubebuilder:validation:Optional
	subjectAlternativeNames?: [...#TLSValidationSubjectAlternativeNamesParameters] @go(SubjectAlternativeNames,[]TLSValidationSubjectAlternativeNamesParameters)

	// TLS validation context trust.
	// +kubebuilder:validation:Optional
	trust: [...#TLSValidationTrustParameters] @go(Trust,[]TLSValidationTrustParameters)
}

#ClientPolicyTLSValidationSubjectAlternativeNamesInitParameters: {
	// Criteria for determining a SAN's match.
	match?: [...#ClientPolicyTLSValidationSubjectAlternativeNamesMatchInitParameters] @go(Match,[]ClientPolicyTLSValidationSubjectAlternativeNamesMatchInitParameters)
}

#ClientPolicyTLSValidationSubjectAlternativeNamesMatchInitParameters: {
	// Values sent must match the specified values exactly.
	exact?: [...null | string] @go(Exact,[]*string)
}

#ClientPolicyTLSValidationSubjectAlternativeNamesMatchObservation: {
	// Values sent must match the specified values exactly.
	exact?: [...null | string] @go(Exact,[]*string)
}

#ClientPolicyTLSValidationSubjectAlternativeNamesMatchParameters: {
	// Values sent must match the specified values exactly.
	// +kubebuilder:validation:Optional
	exact: [...null | string] @go(Exact,[]*string)
}

#ClientPolicyTLSValidationSubjectAlternativeNamesObservation: {
	// Criteria for determining a SAN's match.
	match?: [...#ClientPolicyTLSValidationSubjectAlternativeNamesMatchObservation] @go(Match,[]ClientPolicyTLSValidationSubjectAlternativeNamesMatchObservation)
}

#ClientPolicyTLSValidationSubjectAlternativeNamesParameters: {
	// Criteria for determining a SAN's match.
	// +kubebuilder:validation:Optional
	match: [...#ClientPolicyTLSValidationSubjectAlternativeNamesMatchParameters] @go(Match,[]ClientPolicyTLSValidationSubjectAlternativeNamesMatchParameters)
}

#ClientPolicyTLSValidationTrustFileInitParameters: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)
}

#ClientPolicyTLSValidationTrustFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)
}

#ClientPolicyTLSValidationTrustFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Optional
	certificateChain?: null | string @go(CertificateChain,*string)
}

#ClientPolicyTLSValidationTrustInitParameters: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	acm?: [...#ValidationTrustAcmInitParameters] @go(Acm,[]ValidationTrustAcmInitParameters)

	// Local file certificate.
	file?: [...#ClientPolicyTLSValidationTrustFileInitParameters] @go(File,[]ClientPolicyTLSValidationTrustFileInitParameters)

	// A Secret Discovery Service certificate.
	sds?: [...#ClientPolicyTLSValidationTrustSdsInitParameters] @go(Sds,[]ClientPolicyTLSValidationTrustSdsInitParameters)
}

#ClientPolicyTLSValidationTrustObservation: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	acm?: [...#ValidationTrustAcmObservation] @go(Acm,[]ValidationTrustAcmObservation)

	// Local file certificate.
	file?: [...#ClientPolicyTLSValidationTrustFileObservation] @go(File,[]ClientPolicyTLSValidationTrustFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#ClientPolicyTLSValidationTrustSdsObservation] @go(Sds,[]ClientPolicyTLSValidationTrustSdsObservation)
}

#ClientPolicyTLSValidationTrustParameters: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	// +kubebuilder:validation:Optional
	acm?: [...#ValidationTrustAcmParameters] @go(Acm,[]ValidationTrustAcmParameters)

	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#ClientPolicyTLSValidationTrustFileParameters] @go(File,[]ClientPolicyTLSValidationTrustFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#ClientPolicyTLSValidationTrustSdsParameters] @go(Sds,[]ClientPolicyTLSValidationTrustSdsParameters)
}

#ClientPolicyTLSValidationTrustSdsInitParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ClientPolicyTLSValidationTrustSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ClientPolicyTLSValidationTrustSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Optional
	secretName?: null | string @go(SecretName,*string)
}

#ConnectionPoolGRPCInitParameters: {
	// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
	maxRequests?: null | float64 @go(MaxRequests,*float64)
}

#ConnectionPoolGRPCObservation: {
	// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
	maxRequests?: null | float64 @go(MaxRequests,*float64)
}

#ConnectionPoolGRPCParameters: {
	// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
	// +kubebuilder:validation:Optional
	maxRequests?: null | float64 @go(MaxRequests,*float64)
}

#ConnectionPoolHTTPInitParameters: {
	// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
	maxPendingRequests?: null | float64 @go(MaxPendingRequests,*float64)
}

#ConnectionPoolHTTPObservation: {
	// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
	maxPendingRequests?: null | float64 @go(MaxPendingRequests,*float64)
}

#ConnectionPoolHTTPParameters: {
	// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
	// +kubebuilder:validation:Optional
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
	// +kubebuilder:validation:Optional
	maxPendingRequests?: null | float64 @go(MaxPendingRequests,*float64)
}

#ConnectionPoolHttp2InitParameters: {
	// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
	maxRequests?: null | float64 @go(MaxRequests,*float64)
}

#ConnectionPoolHttp2Observation: {
	// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
	maxRequests?: null | float64 @go(MaxRequests,*float64)
}

#ConnectionPoolHttp2Parameters: {
	// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
	// +kubebuilder:validation:Optional
	maxRequests?: null | float64 @go(MaxRequests,*float64)
}

#DNSInitParameters: {
	// DNS host name for your virtual node.
	hostname?: null | string @go(Hostname,*string)

	// The preferred IP version that this virtual node uses. Valid values: IPv6_PREFERRED, IPv4_PREFERRED, IPv4_ONLY, IPv6_ONLY.
	ipPreference?: null | string @go(IPPreference,*string)

	// The DNS response type for the virtual node. Valid values: LOADBALANCER, ENDPOINTS.
	responseType?: null | string @go(ResponseType,*string)
}

#DNSObservation: {
	// DNS host name for your virtual node.
	hostname?: null | string @go(Hostname,*string)

	// The preferred IP version that this virtual node uses. Valid values: IPv6_PREFERRED, IPv4_PREFERRED, IPv4_ONLY, IPv6_ONLY.
	ipPreference?: null | string @go(IPPreference,*string)

	// The DNS response type for the virtual node. Valid values: LOADBALANCER, ENDPOINTS.
	responseType?: null | string @go(ResponseType,*string)
}

#DNSParameters: {
	// DNS host name for your virtual node.
	// +kubebuilder:validation:Optional
	hostname?: null | string @go(Hostname,*string)

	// The preferred IP version that this virtual node uses. Valid values: IPv6_PREFERRED, IPv4_PREFERRED, IPv4_ONLY, IPv6_ONLY.
	// +kubebuilder:validation:Optional
	ipPreference?: null | string @go(IPPreference,*string)

	// The DNS response type for the virtual node. Valid values: LOADBALANCER, ENDPOINTS.
	// +kubebuilder:validation:Optional
	responseType?: null | string @go(ResponseType,*string)
}

#FileFormatInitParameters: {
	// The logging format for JSON.
	json?: [...#FormatJSONInitParameters] @go(JSON,[]FormatJSONInitParameters)

	// The logging format for text. Must be between 1 and 1000 characters in length.
	text?: null | string @go(Text,*string)
}

#FileFormatObservation: {
	// The logging format for JSON.
	json?: [...#FormatJSONObservation] @go(JSON,[]FormatJSONObservation)

	// The logging format for text. Must be between 1 and 1000 characters in length.
	text?: null | string @go(Text,*string)
}

#FileFormatParameters: {
	// The logging format for JSON.
	// +kubebuilder:validation:Optional
	json?: [...#FormatJSONParameters] @go(JSON,[]FormatJSONParameters)

	// The logging format for text. Must be between 1 and 1000 characters in length.
	// +kubebuilder:validation:Optional
	text?: null | string @go(Text,*string)
}

#FormatJSONInitParameters: {
	// The specified key for the JSON. Must be between 1 and 100 characters in length.
	key?: null | string @go(Key,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | string @go(Value,*string)
}

#FormatJSONObservation: {
	// The specified key for the JSON. Must be between 1 and 100 characters in length.
	key?: null | string @go(Key,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | string @go(Value,*string)
}

#FormatJSONParameters: {
	// The specified key for the JSON. Must be between 1 and 100 characters in length.
	// +kubebuilder:validation:Optional
	key?: null | string @go(Key,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	// +kubebuilder:validation:Optional
	value?: null | string @go(Value,*string)
}

#GRPCIdleInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#GRPCIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#GRPCIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#GRPCPerRequestInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#GRPCPerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#GRPCPerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#HTTPIdleInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#HTTPIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#HTTPIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#HTTPPerRequestInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#HTTPPerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#HTTPPerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#Http2IdleInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#Http2IdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#Http2IdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#Http2PerRequestInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#Http2PerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#Http2PerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#IntervalInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#IntervalObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#IntervalParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#ListenerConnectionPoolInitParameters: {
	// Connection pool information for gRPC listeners.
	grpc?: [...#ConnectionPoolGRPCInitParameters] @go(GRPC,[]ConnectionPoolGRPCInitParameters)

	// Connection pool information for HTTP listeners.
	http?: [...#ConnectionPoolHTTPInitParameters] @go(HTTP,[]ConnectionPoolHTTPInitParameters)

	// Connection pool information for HTTP2 listeners.
	http2?: [...#ConnectionPoolHttp2InitParameters] @go(Http2,[]ConnectionPoolHttp2InitParameters)

	// Connection pool information for TCP listeners.
	tcp?: [...#TCPInitParameters] @go(TCP,[]TCPInitParameters)
}

#ListenerConnectionPoolObservation: {
	// Connection pool information for gRPC listeners.
	grpc?: [...#ConnectionPoolGRPCObservation] @go(GRPC,[]ConnectionPoolGRPCObservation)

	// Connection pool information for HTTP listeners.
	http?: [...#ConnectionPoolHTTPObservation] @go(HTTP,[]ConnectionPoolHTTPObservation)

	// Connection pool information for HTTP2 listeners.
	http2?: [...#ConnectionPoolHttp2Observation] @go(Http2,[]ConnectionPoolHttp2Observation)

	// Connection pool information for TCP listeners.
	tcp?: [...#TCPObservation] @go(TCP,[]TCPObservation)
}

#ListenerConnectionPoolParameters: {
	// Connection pool information for gRPC listeners.
	// +kubebuilder:validation:Optional
	grpc?: [...#ConnectionPoolGRPCParameters] @go(GRPC,[]ConnectionPoolGRPCParameters)

	// Connection pool information for HTTP listeners.
	// +kubebuilder:validation:Optional
	http?: [...#ConnectionPoolHTTPParameters] @go(HTTP,[]ConnectionPoolHTTPParameters)

	// Connection pool information for HTTP2 listeners.
	// +kubebuilder:validation:Optional
	http2?: [...#ConnectionPoolHttp2Parameters] @go(Http2,[]ConnectionPoolHttp2Parameters)

	// Connection pool information for TCP listeners.
	// +kubebuilder:validation:Optional
	tcp?: [...#TCPParameters] @go(TCP,[]TCPParameters)
}

#ListenerHealthCheckInitParameters: {
	// Number of consecutive successful health checks that must occur before declaring listener healthy.
	healthyThreshold?: null | float64 @go(HealthyThreshold,*float64)

	// Time period in milliseconds between each health check execution.
	intervalMillis?: null | float64 @go(IntervalMillis,*float64)

	// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
	path?: null | string @go(Path,*string)

	// Port used for the port mapping.
	port?: null | float64 @go(Port,*float64)

	// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
	protocol?: null | string @go(Protocol,*string)

	// Amount of time to wait when receiving a response from the health check, in milliseconds.
	timeoutMillis?: null | float64 @go(TimeoutMillis,*float64)

	// Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
	unhealthyThreshold?: null | float64 @go(UnhealthyThreshold,*float64)
}

#ListenerHealthCheckObservation: {
	// Number of consecutive successful health checks that must occur before declaring listener healthy.
	healthyThreshold?: null | float64 @go(HealthyThreshold,*float64)

	// Time period in milliseconds between each health check execution.
	intervalMillis?: null | float64 @go(IntervalMillis,*float64)

	// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
	path?: null | string @go(Path,*string)

	// Port used for the port mapping.
	port?: null | float64 @go(Port,*float64)

	// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
	protocol?: null | string @go(Protocol,*string)

	// Amount of time to wait when receiving a response from the health check, in milliseconds.
	timeoutMillis?: null | float64 @go(TimeoutMillis,*float64)

	// Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
	unhealthyThreshold?: null | float64 @go(UnhealthyThreshold,*float64)
}

#ListenerHealthCheckParameters: {
	// Number of consecutive successful health checks that must occur before declaring listener healthy.
	// +kubebuilder:validation:Optional
	healthyThreshold?: null | float64 @go(HealthyThreshold,*float64)

	// Time period in milliseconds between each health check execution.
	// +kubebuilder:validation:Optional
	intervalMillis?: null | float64 @go(IntervalMillis,*float64)

	// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	path?: null | string @go(Path,*string)

	// Port used for the port mapping.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
	// +kubebuilder:validation:Optional
	protocol?: null | string @go(Protocol,*string)

	// Amount of time to wait when receiving a response from the health check, in milliseconds.
	// +kubebuilder:validation:Optional
	timeoutMillis?: null | float64 @go(TimeoutMillis,*float64)

	// Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
	// +kubebuilder:validation:Optional
	unhealthyThreshold?: null | float64 @go(UnhealthyThreshold,*float64)
}

#ListenerPortMappingInitParameters: {
	// Port used for the port mapping.
	port?: null | float64 @go(Port,*float64)

	// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
	protocol?: null | string @go(Protocol,*string)
}

#ListenerPortMappingObservation: {
	// Port used for the port mapping.
	port?: null | float64 @go(Port,*float64)

	// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
	protocol?: null | string @go(Protocol,*string)
}

#ListenerPortMappingParameters: {
	// Port used for the port mapping.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
	// +kubebuilder:validation:Optional
	protocol?: null | string @go(Protocol,*string)
}

#ListenerTLSCertificateFileInitParameters: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	privateKey?: null | string @go(PrivateKey,*string)
}

#ListenerTLSCertificateFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	privateKey?: null | string @go(PrivateKey,*string)
}

#ListenerTLSCertificateFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Optional
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	// +kubebuilder:validation:Optional
	privateKey?: null | string @go(PrivateKey,*string)
}

#ListenerTLSCertificateInitParameters: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	acm?: [...#TLSCertificateAcmInitParameters] @go(Acm,[]TLSCertificateAcmInitParameters)

	// Local file certificate.
	file?: [...#ListenerTLSCertificateFileInitParameters] @go(File,[]ListenerTLSCertificateFileInitParameters)

	// A Secret Discovery Service certificate.
	sds?: [...#ListenerTLSCertificateSdsInitParameters] @go(Sds,[]ListenerTLSCertificateSdsInitParameters)
}

#ListenerTLSCertificateObservation: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	acm?: [...#TLSCertificateAcmObservation] @go(Acm,[]TLSCertificateAcmObservation)

	// Local file certificate.
	file?: [...#ListenerTLSCertificateFileObservation] @go(File,[]ListenerTLSCertificateFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#ListenerTLSCertificateSdsObservation] @go(Sds,[]ListenerTLSCertificateSdsObservation)
}

#ListenerTLSCertificateParameters: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	// +kubebuilder:validation:Optional
	acm?: [...#TLSCertificateAcmParameters] @go(Acm,[]TLSCertificateAcmParameters)

	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#ListenerTLSCertificateFileParameters] @go(File,[]ListenerTLSCertificateFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#ListenerTLSCertificateSdsParameters] @go(Sds,[]ListenerTLSCertificateSdsParameters)
}

#ListenerTLSCertificateSdsInitParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ListenerTLSCertificateSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ListenerTLSCertificateSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Optional
	secretName?: null | string @go(SecretName,*string)
}

#ListenerTLSValidationInitParameters: {
	// SANs for a TLS validation context.
	subjectAlternativeNames?: [...#ListenerTLSValidationSubjectAlternativeNamesInitParameters] @go(SubjectAlternativeNames,[]ListenerTLSValidationSubjectAlternativeNamesInitParameters)

	// TLS validation context trust.
	trust?: [...#ListenerTLSValidationTrustInitParameters] @go(Trust,[]ListenerTLSValidationTrustInitParameters)
}

#ListenerTLSValidationObservation: {
	// SANs for a TLS validation context.
	subjectAlternativeNames?: [...#ListenerTLSValidationSubjectAlternativeNamesObservation] @go(SubjectAlternativeNames,[]ListenerTLSValidationSubjectAlternativeNamesObservation)

	// TLS validation context trust.
	trust?: [...#ListenerTLSValidationTrustObservation] @go(Trust,[]ListenerTLSValidationTrustObservation)
}

#ListenerTLSValidationParameters: {
	// SANs for a TLS validation context.
	// +kubebuilder:validation:Optional
	subjectAlternativeNames?: [...#ListenerTLSValidationSubjectAlternativeNamesParameters] @go(SubjectAlternativeNames,[]ListenerTLSValidationSubjectAlternativeNamesParameters)

	// TLS validation context trust.
	// +kubebuilder:validation:Optional
	trust: [...#ListenerTLSValidationTrustParameters] @go(Trust,[]ListenerTLSValidationTrustParameters)
}

#ListenerTLSValidationSubjectAlternativeNamesInitParameters: {
	// Criteria for determining a SAN's match.
	match?: [...#ListenerTLSValidationSubjectAlternativeNamesMatchInitParameters] @go(Match,[]ListenerTLSValidationSubjectAlternativeNamesMatchInitParameters)
}

#ListenerTLSValidationSubjectAlternativeNamesMatchInitParameters: {
	// Values sent must match the specified values exactly.
	exact?: [...null | string] @go(Exact,[]*string)
}

#ListenerTLSValidationSubjectAlternativeNamesMatchObservation: {
	// Values sent must match the specified values exactly.
	exact?: [...null | string] @go(Exact,[]*string)
}

#ListenerTLSValidationSubjectAlternativeNamesMatchParameters: {
	// Values sent must match the specified values exactly.
	// +kubebuilder:validation:Optional
	exact: [...null | string] @go(Exact,[]*string)
}

#ListenerTLSValidationSubjectAlternativeNamesObservation: {
	// Criteria for determining a SAN's match.
	match?: [...#ListenerTLSValidationSubjectAlternativeNamesMatchObservation] @go(Match,[]ListenerTLSValidationSubjectAlternativeNamesMatchObservation)
}

#ListenerTLSValidationSubjectAlternativeNamesParameters: {
	// Criteria for determining a SAN's match.
	// +kubebuilder:validation:Optional
	match: [...#ListenerTLSValidationSubjectAlternativeNamesMatchParameters] @go(Match,[]ListenerTLSValidationSubjectAlternativeNamesMatchParameters)
}

#ListenerTLSValidationTrustFileInitParameters: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)
}

#ListenerTLSValidationTrustFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)
}

#ListenerTLSValidationTrustFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Optional
	certificateChain?: null | string @go(CertificateChain,*string)
}

#ListenerTLSValidationTrustInitParameters: {
	// Local file certificate.
	file?: [...#ListenerTLSValidationTrustFileInitParameters] @go(File,[]ListenerTLSValidationTrustFileInitParameters)

	// A Secret Discovery Service certificate.
	sds?: [...#ListenerTLSValidationTrustSdsInitParameters] @go(Sds,[]ListenerTLSValidationTrustSdsInitParameters)
}

#ListenerTLSValidationTrustObservation: {
	// Local file certificate.
	file?: [...#ListenerTLSValidationTrustFileObservation] @go(File,[]ListenerTLSValidationTrustFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#ListenerTLSValidationTrustSdsObservation] @go(Sds,[]ListenerTLSValidationTrustSdsObservation)
}

#ListenerTLSValidationTrustParameters: {
	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#ListenerTLSValidationTrustFileParameters] @go(File,[]ListenerTLSValidationTrustFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#ListenerTLSValidationTrustSdsParameters] @go(Sds,[]ListenerTLSValidationTrustSdsParameters)
}

#ListenerTLSValidationTrustSdsInitParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ListenerTLSValidationTrustSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ListenerTLSValidationTrustSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Optional
	secretName?: null | string @go(SecretName,*string)
}

#ListenerTimeoutInitParameters: {
	// Connection pool information for gRPC listeners.
	grpc?: [...#TimeoutGRPCInitParameters] @go(GRPC,[]TimeoutGRPCInitParameters)

	// Connection pool information for HTTP listeners.
	http?: [...#TimeoutHTTPInitParameters] @go(HTTP,[]TimeoutHTTPInitParameters)

	// Connection pool information for HTTP2 listeners.
	http2?: [...#TimeoutHttp2InitParameters] @go(Http2,[]TimeoutHttp2InitParameters)

	// Connection pool information for TCP listeners.
	tcp?: [...#TimeoutTCPInitParameters] @go(TCP,[]TimeoutTCPInitParameters)
}

#ListenerTimeoutObservation: {
	// Connection pool information for gRPC listeners.
	grpc?: [...#TimeoutGRPCObservation] @go(GRPC,[]TimeoutGRPCObservation)

	// Connection pool information for HTTP listeners.
	http?: [...#TimeoutHTTPObservation] @go(HTTP,[]TimeoutHTTPObservation)

	// Connection pool information for HTTP2 listeners.
	http2?: [...#TimeoutHttp2Observation] @go(Http2,[]TimeoutHttp2Observation)

	// Connection pool information for TCP listeners.
	tcp?: [...#TimeoutTCPObservation] @go(TCP,[]TimeoutTCPObservation)
}

#ListenerTimeoutParameters: {
	// Connection pool information for gRPC listeners.
	// +kubebuilder:validation:Optional
	grpc?: [...#TimeoutGRPCParameters] @go(GRPC,[]TimeoutGRPCParameters)

	// Connection pool information for HTTP listeners.
	// +kubebuilder:validation:Optional
	http?: [...#TimeoutHTTPParameters] @go(HTTP,[]TimeoutHTTPParameters)

	// Connection pool information for HTTP2 listeners.
	// +kubebuilder:validation:Optional
	http2?: [...#TimeoutHttp2Parameters] @go(Http2,[]TimeoutHttp2Parameters)

	// Connection pool information for TCP listeners.
	// +kubebuilder:validation:Optional
	tcp?: [...#TimeoutTCPParameters] @go(TCP,[]TimeoutTCPParameters)
}

#LoggingAccessLogFileInitParameters: {
	// The specified format for the logs.
	format?: [...#FileFormatInitParameters] @go(Format,[]FileFormatInitParameters)

	// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
	path?: null | string @go(Path,*string)
}

#LoggingAccessLogFileObservation: {
	// The specified format for the logs.
	format?: [...#FileFormatObservation] @go(Format,[]FileFormatObservation)

	// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
	path?: null | string @go(Path,*string)
}

#LoggingAccessLogFileParameters: {
	// The specified format for the logs.
	// +kubebuilder:validation:Optional
	format?: [...#FileFormatParameters] @go(Format,[]FileFormatParameters)

	// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	path?: null | string @go(Path,*string)
}

#LoggingAccessLogInitParameters: {
	// Local file certificate.
	file?: [...#LoggingAccessLogFileInitParameters] @go(File,[]LoggingAccessLogFileInitParameters)
}

#LoggingAccessLogObservation: {
	// Local file certificate.
	file?: [...#LoggingAccessLogFileObservation] @go(File,[]LoggingAccessLogFileObservation)
}

#LoggingAccessLogParameters: {
	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#LoggingAccessLogFileParameters] @go(File,[]LoggingAccessLogFileParameters)
}

#OutlierDetectionInitParameters: {
	// Base amount of time for which a host is ejected.
	baseEjectionDuration?: [...#BaseEjectionDurationInitParameters] @go(BaseEjectionDuration,[]BaseEjectionDurationInitParameters)

	// Time interval between ejection sweep analysis.
	interval?: [...#IntervalInitParameters] @go(Interval,[]IntervalInitParameters)

	// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
	// Minimum value of 0. Maximum value of 100.
	maxEjectionPercent?: null | float64 @go(MaxEjectionPercent,*float64)

	// Number of consecutive 5xx errors required for ejection. Minimum value of 1.
	maxServerErrors?: null | float64 @go(MaxServerErrors,*float64)
}

#OutlierDetectionObservation: {
	// Base amount of time for which a host is ejected.
	baseEjectionDuration?: [...#BaseEjectionDurationObservation] @go(BaseEjectionDuration,[]BaseEjectionDurationObservation)

	// Time interval between ejection sweep analysis.
	interval?: [...#IntervalObservation] @go(Interval,[]IntervalObservation)

	// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
	// Minimum value of 0. Maximum value of 100.
	maxEjectionPercent?: null | float64 @go(MaxEjectionPercent,*float64)

	// Number of consecutive 5xx errors required for ejection. Minimum value of 1.
	maxServerErrors?: null | float64 @go(MaxServerErrors,*float64)
}

#OutlierDetectionParameters: {
	// Base amount of time for which a host is ejected.
	// +kubebuilder:validation:Optional
	baseEjectionDuration: [...#BaseEjectionDurationParameters] @go(BaseEjectionDuration,[]BaseEjectionDurationParameters)

	// Time interval between ejection sweep analysis.
	// +kubebuilder:validation:Optional
	interval: [...#IntervalParameters] @go(Interval,[]IntervalParameters)

	// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
	// Minimum value of 0. Maximum value of 100.
	// +kubebuilder:validation:Optional
	maxEjectionPercent?: null | float64 @go(MaxEjectionPercent,*float64)

	// Number of consecutive 5xx errors required for ejection. Minimum value of 1.
	// +kubebuilder:validation:Optional
	maxServerErrors?: null | float64 @go(MaxServerErrors,*float64)
}

#ServiceDiscoveryInitParameters: {
	// Any AWS Cloud Map information for the virtual node.
	awsCloudMap?: [...#AwsCloudMapInitParameters] @go(AwsCloudMap,[]AwsCloudMapInitParameters)

	// DNS service name for the virtual node.
	dns?: [...#DNSInitParameters] @go(DNS,[]DNSInitParameters)
}

#ServiceDiscoveryObservation: {
	// Any AWS Cloud Map information for the virtual node.
	awsCloudMap?: [...#AwsCloudMapObservation] @go(AwsCloudMap,[]AwsCloudMapObservation)

	// DNS service name for the virtual node.
	dns?: [...#DNSObservation] @go(DNS,[]DNSObservation)
}

#ServiceDiscoveryParameters: {
	// Any AWS Cloud Map information for the virtual node.
	// +kubebuilder:validation:Optional
	awsCloudMap?: [...#AwsCloudMapParameters] @go(AwsCloudMap,[]AwsCloudMapParameters)

	// DNS service name for the virtual node.
	// +kubebuilder:validation:Optional
	dns?: [...#DNSParameters] @go(DNS,[]DNSParameters)
}

#SpecBackendDefaultsInitParameters: {
	// Client policy for the backend.
	clientPolicy?: [...#BackendDefaultsClientPolicyInitParameters] @go(ClientPolicy,[]BackendDefaultsClientPolicyInitParameters)
}

#SpecBackendDefaultsObservation: {
	// Client policy for the backend.
	clientPolicy?: [...#BackendDefaultsClientPolicyObservation] @go(ClientPolicy,[]BackendDefaultsClientPolicyObservation)
}

#SpecBackendDefaultsParameters: {
	// Client policy for the backend.
	// +kubebuilder:validation:Optional
	clientPolicy?: [...#BackendDefaultsClientPolicyParameters] @go(ClientPolicy,[]BackendDefaultsClientPolicyParameters)
}

#SpecListenerInitParameters: {
	// Connection pool information for the listener.
	connectionPool?: [...#ListenerConnectionPoolInitParameters] @go(ConnectionPool,[]ListenerConnectionPoolInitParameters)

	// Health check information for the listener.
	healthCheck?: [...#ListenerHealthCheckInitParameters] @go(HealthCheck,[]ListenerHealthCheckInitParameters)

	// Outlier detection information for the listener.
	outlierDetection?: [...#OutlierDetectionInitParameters] @go(OutlierDetection,[]OutlierDetectionInitParameters)

	// Port mapping information for the listener.
	portMapping?: [...#ListenerPortMappingInitParameters] @go(PortMapping,[]ListenerPortMappingInitParameters)

	// Transport Layer Security (TLS) client policy.
	tls?: [...#SpecListenerTLSInitParameters] @go(TLS,[]SpecListenerTLSInitParameters)

	// Timeouts for different protocols.
	timeout?: [...#ListenerTimeoutInitParameters] @go(Timeout,[]ListenerTimeoutInitParameters)
}

#SpecListenerObservation: {
	// Connection pool information for the listener.
	connectionPool?: [...#ListenerConnectionPoolObservation] @go(ConnectionPool,[]ListenerConnectionPoolObservation)

	// Health check information for the listener.
	healthCheck?: [...#ListenerHealthCheckObservation] @go(HealthCheck,[]ListenerHealthCheckObservation)

	// Outlier detection information for the listener.
	outlierDetection?: [...#OutlierDetectionObservation] @go(OutlierDetection,[]OutlierDetectionObservation)

	// Port mapping information for the listener.
	portMapping?: [...#ListenerPortMappingObservation] @go(PortMapping,[]ListenerPortMappingObservation)

	// Transport Layer Security (TLS) client policy.
	tls?: [...#SpecListenerTLSObservation] @go(TLS,[]SpecListenerTLSObservation)

	// Timeouts for different protocols.
	timeout?: [...#ListenerTimeoutObservation] @go(Timeout,[]ListenerTimeoutObservation)
}

#SpecListenerParameters: {
	// Connection pool information for the listener.
	// +kubebuilder:validation:Optional
	connectionPool?: [...#ListenerConnectionPoolParameters] @go(ConnectionPool,[]ListenerConnectionPoolParameters)

	// Health check information for the listener.
	// +kubebuilder:validation:Optional
	healthCheck?: [...#ListenerHealthCheckParameters] @go(HealthCheck,[]ListenerHealthCheckParameters)

	// Outlier detection information for the listener.
	// +kubebuilder:validation:Optional
	outlierDetection?: [...#OutlierDetectionParameters] @go(OutlierDetection,[]OutlierDetectionParameters)

	// Port mapping information for the listener.
	// +kubebuilder:validation:Optional
	portMapping: [...#ListenerPortMappingParameters] @go(PortMapping,[]ListenerPortMappingParameters)

	// Transport Layer Security (TLS) client policy.
	// +kubebuilder:validation:Optional
	tls?: [...#SpecListenerTLSParameters] @go(TLS,[]SpecListenerTLSParameters)

	// Timeouts for different protocols.
	// +kubebuilder:validation:Optional
	timeout?: [...#ListenerTimeoutParameters] @go(Timeout,[]ListenerTimeoutParameters)
}

#SpecListenerTLSInitParameters: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	certificate?: [...#ListenerTLSCertificateInitParameters] @go(Certificate,[]ListenerTLSCertificateInitParameters)

	// Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
	mode?: null | string @go(Mode,*string)

	// TLS validation context.
	validation?: [...#ListenerTLSValidationInitParameters] @go(Validation,[]ListenerTLSValidationInitParameters)
}

#SpecListenerTLSObservation: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	certificate?: [...#ListenerTLSCertificateObservation] @go(Certificate,[]ListenerTLSCertificateObservation)

	// Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
	mode?: null | string @go(Mode,*string)

	// TLS validation context.
	validation?: [...#ListenerTLSValidationObservation] @go(Validation,[]ListenerTLSValidationObservation)
}

#SpecListenerTLSParameters: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	// +kubebuilder:validation:Optional
	certificate: [...#ListenerTLSCertificateParameters] @go(Certificate,[]ListenerTLSCertificateParameters)

	// Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
	// +kubebuilder:validation:Optional
	mode?: null | string @go(Mode,*string)

	// TLS validation context.
	// +kubebuilder:validation:Optional
	validation?: [...#ListenerTLSValidationParameters] @go(Validation,[]ListenerTLSValidationParameters)
}

#SpecLoggingInitParameters: {
	// Access log configuration for a virtual node.
	accessLog?: [...#LoggingAccessLogInitParameters] @go(AccessLog,[]LoggingAccessLogInitParameters)
}

#SpecLoggingObservation: {
	// Access log configuration for a virtual node.
	accessLog?: [...#LoggingAccessLogObservation] @go(AccessLog,[]LoggingAccessLogObservation)
}

#SpecLoggingParameters: {
	// Access log configuration for a virtual node.
	// +kubebuilder:validation:Optional
	accessLog?: [...#LoggingAccessLogParameters] @go(AccessLog,[]LoggingAccessLogParameters)
}

#TCPIdleInitParameters: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#TCPIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	value?: null | float64 @go(Value,*float64)
}

#TCPIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Optional
	unit?: null | string @go(Unit,*string)

	// The specified value for the JSON. Must be between 1 and 100 characters in length.
	// +kubebuilder:validation:Optional
	value?: null | float64 @go(Value,*float64)
}

#TCPInitParameters: {
	// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
	maxConnections?: null | float64 @go(MaxConnections,*float64)
}

#TCPObservation: {
	// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
	maxConnections?: null | float64 @go(MaxConnections,*float64)
}

#TCPParameters: {
	// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
	// +kubebuilder:validation:Optional
	maxConnections?: null | float64 @go(MaxConnections,*float64)
}

#TLSCertificateAcmInitParameters: {
	// ARN for the certificate.
	certificateArn?: null | string @go(CertificateArn,*string)
}

#TLSCertificateAcmObservation: {
	// ARN for the certificate.
	certificateArn?: null | string @go(CertificateArn,*string)
}

#TLSCertificateAcmParameters: {
	// ARN for the certificate.
	// +kubebuilder:validation:Optional
	certificateArn?: null | string @go(CertificateArn,*string)
}

#TLSCertificateFileInitParameters: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	privateKey?: null | string @go(PrivateKey,*string)
}

#TLSCertificateFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	privateKey?: null | string @go(PrivateKey,*string)
}

#TLSCertificateFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Optional
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	// +kubebuilder:validation:Optional
	privateKey?: null | string @go(PrivateKey,*string)
}

#TLSCertificateSdsInitParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#TLSCertificateSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#TLSCertificateSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Optional
	secretName?: null | string @go(SecretName,*string)
}

#TLSValidationSubjectAlternativeNamesInitParameters: {
	// Criteria for determining a SAN's match.
	match?: [...#TLSValidationSubjectAlternativeNamesMatchInitParameters] @go(Match,[]TLSValidationSubjectAlternativeNamesMatchInitParameters)
}

#TLSValidationSubjectAlternativeNamesMatchInitParameters: {
	// Values sent must match the specified values exactly.
	exact?: [...null | string] @go(Exact,[]*string)
}

#TLSValidationSubjectAlternativeNamesMatchObservation: {
	// Values sent must match the specified values exactly.
	exact?: [...null | string] @go(Exact,[]*string)
}

#TLSValidationSubjectAlternativeNamesMatchParameters: {
	// Values sent must match the specified values exactly.
	// +kubebuilder:validation:Optional
	exact: [...null | string] @go(Exact,[]*string)
}

#TLSValidationSubjectAlternativeNamesObservation: {
	// Criteria for determining a SAN's match.
	match?: [...#TLSValidationSubjectAlternativeNamesMatchObservation] @go(Match,[]TLSValidationSubjectAlternativeNamesMatchObservation)
}

#TLSValidationSubjectAlternativeNamesParameters: {
	// Criteria for determining a SAN's match.
	// +kubebuilder:validation:Optional
	match: [...#TLSValidationSubjectAlternativeNamesMatchParameters] @go(Match,[]TLSValidationSubjectAlternativeNamesMatchParameters)
}

#TLSValidationTrustFileInitParameters: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)
}

#TLSValidationTrustFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)
}

#TLSValidationTrustFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Optional
	certificateChain?: null | string @go(CertificateChain,*string)
}

#TLSValidationTrustInitParameters: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	acm?: [...#TrustAcmInitParameters] @go(Acm,[]TrustAcmInitParameters)

	// Local file certificate.
	file?: [...#TLSValidationTrustFileInitParameters] @go(File,[]TLSValidationTrustFileInitParameters)

	// A Secret Discovery Service certificate.
	sds?: [...#TLSValidationTrustSdsInitParameters] @go(Sds,[]TLSValidationTrustSdsInitParameters)
}

#TLSValidationTrustObservation: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	acm?: [...#TrustAcmObservation] @go(Acm,[]TrustAcmObservation)

	// Local file certificate.
	file?: [...#TLSValidationTrustFileObservation] @go(File,[]TLSValidationTrustFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#TLSValidationTrustSdsObservation] @go(Sds,[]TLSValidationTrustSdsObservation)
}

#TLSValidationTrustParameters: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	// +kubebuilder:validation:Optional
	acm?: [...#TrustAcmParameters] @go(Acm,[]TrustAcmParameters)

	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#TLSValidationTrustFileParameters] @go(File,[]TLSValidationTrustFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#TLSValidationTrustSdsParameters] @go(Sds,[]TLSValidationTrustSdsParameters)
}

#TLSValidationTrustSdsInitParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#TLSValidationTrustSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#TLSValidationTrustSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Optional
	secretName?: null | string @go(SecretName,*string)
}

#TimeoutGRPCInitParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#GRPCIdleInitParameters] @go(Idle,[]GRPCIdleInitParameters)

	// Per request timeout.
	perRequest?: [...#GRPCPerRequestInitParameters] @go(PerRequest,[]GRPCPerRequestInitParameters)
}

#TimeoutGRPCObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#GRPCIdleObservation] @go(Idle,[]GRPCIdleObservation)

	// Per request timeout.
	perRequest?: [...#GRPCPerRequestObservation] @go(PerRequest,[]GRPCPerRequestObservation)
}

#TimeoutGRPCParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#GRPCIdleParameters] @go(Idle,[]GRPCIdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#GRPCPerRequestParameters] @go(PerRequest,[]GRPCPerRequestParameters)
}

#TimeoutHTTPInitParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#HTTPIdleInitParameters] @go(Idle,[]HTTPIdleInitParameters)

	// Per request timeout.
	perRequest?: [...#HTTPPerRequestInitParameters] @go(PerRequest,[]HTTPPerRequestInitParameters)
}

#TimeoutHTTPObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#HTTPIdleObservation] @go(Idle,[]HTTPIdleObservation)

	// Per request timeout.
	perRequest?: [...#HTTPPerRequestObservation] @go(PerRequest,[]HTTPPerRequestObservation)
}

#TimeoutHTTPParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#HTTPIdleParameters] @go(Idle,[]HTTPIdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#HTTPPerRequestParameters] @go(PerRequest,[]HTTPPerRequestParameters)
}

#TimeoutHttp2InitParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#Http2IdleInitParameters] @go(Idle,[]Http2IdleInitParameters)

	// Per request timeout.
	perRequest?: [...#Http2PerRequestInitParameters] @go(PerRequest,[]Http2PerRequestInitParameters)
}

#TimeoutHttp2Observation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#Http2IdleObservation] @go(Idle,[]Http2IdleObservation)

	// Per request timeout.
	perRequest?: [...#Http2PerRequestObservation] @go(PerRequest,[]Http2PerRequestObservation)
}

#TimeoutHttp2Parameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#Http2IdleParameters] @go(Idle,[]Http2IdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#Http2PerRequestParameters] @go(PerRequest,[]Http2PerRequestParameters)
}

#TimeoutTCPInitParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#TCPIdleInitParameters] @go(Idle,[]TCPIdleInitParameters)
}

#TimeoutTCPObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#TCPIdleObservation] @go(Idle,[]TCPIdleObservation)
}

#TimeoutTCPParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#TCPIdleParameters] @go(Idle,[]TCPIdleParameters)
}

#TrustAcmInitParameters: {
	// One or more ACM ARNs.
	certificateAuthorityArns?: [...null | string] @go(CertificateAuthorityArns,[]*string)
}

#TrustAcmObservation: {
	// One or more ACM ARNs.
	certificateAuthorityArns?: [...null | string] @go(CertificateAuthorityArns,[]*string)
}

#TrustAcmParameters: {
	// One or more ACM ARNs.
	// +kubebuilder:validation:Optional
	certificateAuthorityArns: [...null | string] @go(CertificateAuthorityArns,[]*string)
}

#ValidationTrustAcmInitParameters: {
	// One or more ACM ARNs.
	certificateAuthorityArns?: [...null | string] @go(CertificateAuthorityArns,[]*string)
}

#ValidationTrustAcmObservation: {
	// One or more ACM ARNs.
	certificateAuthorityArns?: [...null | string] @go(CertificateAuthorityArns,[]*string)
}

#ValidationTrustAcmParameters: {
	// One or more ACM ARNs.
	// +kubebuilder:validation:Optional
	certificateAuthorityArns: [...null | string] @go(CertificateAuthorityArns,[]*string)
}

#VirtualNodeInitParameters: {
	// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
	meshOwner?: null | string @go(MeshOwner,*string)

	// Name to use for the virtual node. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)

	// Virtual node specification to apply.
	spec?: [...#VirtualNodeSpecInitParameters] @go(Spec,[]VirtualNodeSpecInitParameters)

	// Key-value map of resource tags.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)
}

#VirtualNodeObservation: {
	// ARN of the virtual node.
	arn?: null | string @go(Arn,*string)

	// Creation date of the virtual node.
	createdDate?: null | string @go(CreatedDate,*string)

	// ID of the virtual node.
	id?: null | string @go(ID,*string)

	// Last update date of the virtual node.
	lastUpdatedDate?: null | string @go(LastUpdatedDate,*string)

	// Name of the service mesh in which to create the virtual node. Must be between 1 and 255 characters in length.
	meshName?: null | string @go(MeshName,*string)

	// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
	meshOwner?: null | string @go(MeshOwner,*string)

	// Name to use for the virtual node. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)

	// Resource owner's AWS account ID.
	resourceOwner?: null | string @go(ResourceOwner,*string)

	// Virtual node specification to apply.
	spec?: [...#VirtualNodeSpecObservation] @go(Spec,[]VirtualNodeSpecObservation)

	// Key-value map of resource tags.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)

	// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
	tagsAll?: {[string]: null | string} @go(TagsAll,map[string]*string)
}

#VirtualNodeParameters: {
	// Name of the service mesh in which to create the virtual node. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.Mesh
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	meshName?: null | string @go(MeshName,*string)

	// Reference to a Mesh in appmesh to populate meshName.
	// +kubebuilder:validation:Optional
	meshNameRef?: null | v1.#Reference @go(MeshNameRef,*v1.Reference)

	// Selector for a Mesh in appmesh to populate meshName.
	// +kubebuilder:validation:Optional
	meshNameSelector?: null | v1.#Selector @go(MeshNameSelector,*v1.Selector)

	// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
	// +kubebuilder:validation:Optional
	meshOwner?: null | string @go(MeshOwner,*string)

	// Name to use for the virtual node. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	region?: null | string @go(Region,*string)

	// Virtual node specification to apply.
	// +kubebuilder:validation:Optional
	spec?: [...#VirtualNodeSpecParameters] @go(Spec,[]VirtualNodeSpecParameters)

	// Key-value map of resource tags.
	// +kubebuilder:validation:Optional
	tags?: {[string]: null | string} @go(Tags,map[string]*string)
}

#VirtualNodeSpecInitParameters: {
	// Backends to which the virtual node is expected to send outbound traffic.
	backend?: [...#BackendInitParameters] @go(Backend,[]BackendInitParameters)

	// Defaults for backends.
	backendDefaults?: [...#SpecBackendDefaultsInitParameters] @go(BackendDefaults,[]SpecBackendDefaultsInitParameters)

	// Listeners from which the virtual node is expected to receive inbound traffic.
	listener?: [...#SpecListenerInitParameters] @go(Listener,[]SpecListenerInitParameters)

	// Inbound and outbound access logging information for the virtual node.
	logging?: [...#SpecLoggingInitParameters] @go(Logging,[]SpecLoggingInitParameters)

	// Service discovery information for the virtual node.
	serviceDiscovery?: [...#ServiceDiscoveryInitParameters] @go(ServiceDiscovery,[]ServiceDiscoveryInitParameters)
}

#VirtualNodeSpecObservation: {
	// Backends to which the virtual node is expected to send outbound traffic.
	backend?: [...#BackendObservation] @go(Backend,[]BackendObservation)

	// Defaults for backends.
	backendDefaults?: [...#SpecBackendDefaultsObservation] @go(BackendDefaults,[]SpecBackendDefaultsObservation)

	// Listeners from which the virtual node is expected to receive inbound traffic.
	listener?: [...#SpecListenerObservation] @go(Listener,[]SpecListenerObservation)

	// Inbound and outbound access logging information for the virtual node.
	logging?: [...#SpecLoggingObservation] @go(Logging,[]SpecLoggingObservation)

	// Service discovery information for the virtual node.
	serviceDiscovery?: [...#ServiceDiscoveryObservation] @go(ServiceDiscovery,[]ServiceDiscoveryObservation)
}

#VirtualNodeSpecParameters: {
	// Backends to which the virtual node is expected to send outbound traffic.
	// +kubebuilder:validation:Optional
	backend?: [...#BackendParameters] @go(Backend,[]BackendParameters)

	// Defaults for backends.
	// +kubebuilder:validation:Optional
	backendDefaults?: [...#SpecBackendDefaultsParameters] @go(BackendDefaults,[]SpecBackendDefaultsParameters)

	// Listeners from which the virtual node is expected to receive inbound traffic.
	// +kubebuilder:validation:Optional
	listener?: [...#SpecListenerParameters] @go(Listener,[]SpecListenerParameters)

	// Inbound and outbound access logging information for the virtual node.
	// +kubebuilder:validation:Optional
	logging?: [...#SpecLoggingParameters] @go(Logging,[]SpecLoggingParameters)

	// Service discovery information for the virtual node.
	// +kubebuilder:validation:Optional
	serviceDiscovery?: [...#ServiceDiscoveryParameters] @go(ServiceDiscovery,[]ServiceDiscoveryParameters)
}

#VirtualServiceClientPolicyInitParameters: {
	// Transport Layer Security (TLS) client policy.
	tls?: [...#ClientPolicyTLSInitParameters] @go(TLS,[]ClientPolicyTLSInitParameters)
}

#VirtualServiceClientPolicyObservation: {
	// Transport Layer Security (TLS) client policy.
	tls?: [...#ClientPolicyTLSObservation] @go(TLS,[]ClientPolicyTLSObservation)
}

#VirtualServiceClientPolicyParameters: {
	// Transport Layer Security (TLS) client policy.
	// +kubebuilder:validation:Optional
	tls?: [...#ClientPolicyTLSParameters] @go(TLS,[]ClientPolicyTLSParameters)
}

// VirtualNodeSpec defines the desired state of VirtualNode
#VirtualNodeSpec: {
	v1.#ResourceSpec
	forProvider: #VirtualNodeParameters @go(ForProvider)

	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #VirtualNodeInitParameters @go(InitProvider)
}

// VirtualNodeStatus defines the observed state of VirtualNode.
#VirtualNodeStatus: {
	v1.#ResourceStatus
	atProvider?: #VirtualNodeObservation @go(AtProvider)
}

// VirtualNode is the Schema for the VirtualNodes API. Provides an AWS App Mesh virtual node resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
#VirtualNode: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.spec) || (has(self.initProvider) && has(self.initProvider.spec))",message="spec.forProvider.spec is a required parameter"
	spec:    #VirtualNodeSpec   @go(Spec)
	status?: #VirtualNodeStatus @go(Status)
}

// VirtualNodeList contains a list of VirtualNodes
#VirtualNodeList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VirtualNode] @go(Items,[]VirtualNode)
}
