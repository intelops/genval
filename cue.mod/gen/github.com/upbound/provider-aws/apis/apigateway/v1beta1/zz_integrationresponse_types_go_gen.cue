// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-aws/apis/apigateway/v1beta1

package v1beta1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#IntegrationResponseInitParameters: {
	// How to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT. If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
	contentHandling?: null | string @go(ContentHandling,*string)

	// Map of response parameters that can be read from the backend response. For example: response_parameters = { "method.response.header.X-Some-Header" = "integration.response.header.X-Some-Other-Header" }.
	responseParameters?: {[string]: null | string} @go(ResponseParameters,map[string]*string)

	// Map of templates used to transform the integration response body.
	responseTemplates?: {[string]: null | string} @go(ResponseTemplates,map[string]*string)

	// Regular expression pattern used to choose an integration response based on the response from the backend. Omit configuring this to make the integration the default one. If the backend is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS backends, the HTTP status code is matched.
	selectionPattern?: null | string @go(SelectionPattern,*string)
}

#IntegrationResponseObservation: {
	// How to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT. If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
	contentHandling?: null | string @go(ContentHandling,*string)

	// HTTP method (GET, POST, PUT, DELETE, HEAD, OPTIONS, ANY).
	httpMethod?: null | string @go(HTTPMethod,*string)
	id?:         null | string @go(ID,*string)

	// API resource ID.
	resourceId?: null | string @go(ResourceID,*string)

	// Map of response parameters that can be read from the backend response. For example: response_parameters = { "method.response.header.X-Some-Header" = "integration.response.header.X-Some-Other-Header" }.
	responseParameters?: {[string]: null | string} @go(ResponseParameters,map[string]*string)

	// Map of templates used to transform the integration response body.
	responseTemplates?: {[string]: null | string} @go(ResponseTemplates,map[string]*string)

	// ID of the associated REST API.
	restApiId?: null | string @go(RestAPIID,*string)

	// Regular expression pattern used to choose an integration response based on the response from the backend. Omit configuring this to make the integration the default one. If the backend is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS backends, the HTTP status code is matched.
	selectionPattern?: null | string @go(SelectionPattern,*string)

	// HTTP status code.
	statusCode?: null | string @go(StatusCode,*string)
}

#IntegrationResponseParameters: {
	// How to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT. If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
	// +kubebuilder:validation:Optional
	contentHandling?: null | string @go(ContentHandling,*string)

	// HTTP method (GET, POST, PUT, DELETE, HEAD, OPTIONS, ANY).
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/apigateway/v1beta1.Method
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("http_method",false)
	// +kubebuilder:validation:Optional
	httpMethod?: null | string @go(HTTPMethod,*string)

	// Reference to a Method in apigateway to populate httpMethod.
	// +kubebuilder:validation:Optional
	httpMethodRef?: null | v1.#Reference @go(HTTPMethodRef,*v1.Reference)

	// Selector for a Method in apigateway to populate httpMethod.
	// +kubebuilder:validation:Optional
	httpMethodSelector?: null | v1.#Selector @go(HTTPMethodSelector,*v1.Selector)

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	region?: null | string @go(Region,*string)

	// API resource ID.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/apigateway/v1beta1.Resource
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	resourceId?: null | string @go(ResourceID,*string)

	// Reference to a Resource in apigateway to populate resourceId.
	// +kubebuilder:validation:Optional
	resourceIdRef?: null | v1.#Reference @go(ResourceIDRef,*v1.Reference)

	// Selector for a Resource in apigateway to populate resourceId.
	// +kubebuilder:validation:Optional
	resourceIdSelector?: null | v1.#Selector @go(ResourceIDSelector,*v1.Selector)

	// Map of response parameters that can be read from the backend response. For example: response_parameters = { "method.response.header.X-Some-Header" = "integration.response.header.X-Some-Other-Header" }.
	// +kubebuilder:validation:Optional
	responseParameters?: {[string]: null | string} @go(ResponseParameters,map[string]*string)

	// Map of templates used to transform the integration response body.
	// +kubebuilder:validation:Optional
	responseTemplates?: {[string]: null | string} @go(ResponseTemplates,map[string]*string)

	// ID of the associated REST API.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/apigateway/v1beta1.RestAPI
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	restApiId?: null | string @go(RestAPIID,*string)

	// Reference to a RestAPI in apigateway to populate restApiId.
	// +kubebuilder:validation:Optional
	restApiIdRef?: null | v1.#Reference @go(RestAPIIDRef,*v1.Reference)

	// Selector for a RestAPI in apigateway to populate restApiId.
	// +kubebuilder:validation:Optional
	restApiIdSelector?: null | v1.#Selector @go(RestAPIIDSelector,*v1.Selector)

	// Regular expression pattern used to choose an integration response based on the response from the backend. Omit configuring this to make the integration the default one. If the backend is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS backends, the HTTP status code is matched.
	// +kubebuilder:validation:Optional
	selectionPattern?: null | string @go(SelectionPattern,*string)

	// HTTP status code.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/apigateway/v1beta1.MethodResponse
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("status_code",false)
	// +kubebuilder:validation:Optional
	statusCode?: null | string @go(StatusCode,*string)

	// Reference to a MethodResponse in apigateway to populate statusCode.
	// +kubebuilder:validation:Optional
	statusCodeRef?: null | v1.#Reference @go(StatusCodeRef,*v1.Reference)

	// Selector for a MethodResponse in apigateway to populate statusCode.
	// +kubebuilder:validation:Optional
	statusCodeSelector?: null | v1.#Selector @go(StatusCodeSelector,*v1.Selector)
}

// IntegrationResponseSpec defines the desired state of IntegrationResponse
#IntegrationResponseSpec: {
	v1.#ResourceSpec
	forProvider: #IntegrationResponseParameters @go(ForProvider)

	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #IntegrationResponseInitParameters @go(InitProvider)
}

// IntegrationResponseStatus defines the observed state of IntegrationResponse.
#IntegrationResponseStatus: {
	v1.#ResourceStatus
	atProvider?: #IntegrationResponseObservation @go(AtProvider)
}

// IntegrationResponse is the Schema for the IntegrationResponses API. Provides an HTTP Method Integration Response for an API Gateway Resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
#IntegrationResponse: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta         @go(ObjectMeta)
	spec:      #IntegrationResponseSpec   @go(Spec)
	status?:   #IntegrationResponseStatus @go(Status)
}

// IntegrationResponseList contains a list of IntegrationResponses
#IntegrationResponseList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#IntegrationResponse] @go(Items,[]IntegrationResponse)
}
