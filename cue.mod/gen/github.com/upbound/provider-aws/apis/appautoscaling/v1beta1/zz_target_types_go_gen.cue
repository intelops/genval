// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-aws/apis/appautoscaling/v1beta1

package v1beta1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#TargetInitParameters: {
	// Max capacity of the scalable target.
	maxCapacity?: null | float64 @go(MaxCapacity,*float64)

	// Min capacity of the scalable target.
	minCapacity?: null | float64 @go(MinCapacity,*float64)

	// Key-value map of resource tags.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)
}

#TargetObservation: {
	// The ARN of the scalable target.
	arn?: null | string @go(Arn,*string)
	id?:  null | string @go(ID,*string)

	// Max capacity of the scalable target.
	maxCapacity?: null | float64 @go(MaxCapacity,*float64)

	// Min capacity of the scalable target.
	minCapacity?: null | float64 @go(MinCapacity,*float64)

	// Resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the ResourceId parameter at: AWS Application Auto Scaling API Reference
	resourceId?: null | string @go(ResourceID,*string)

	// ARN of the IAM role that allows Application AutoScaling to modify your scalable target on your behalf. This defaults to an IAM Service-Linked Role for most services and custom IAM Roles are ignored by the API for those namespaces. See the AWS Application Auto Scaling documentation for more information about how this service interacts with IAM.
	roleArn?: null | string @go(RoleArn,*string)

	// Scalable dimension of the scalable target. Documentation can be found in the ScalableDimension parameter at: AWS Application Auto Scaling API Reference
	scalableDimension?: null | string @go(ScalableDimension,*string)

	// AWS service namespace of the scalable target. Documentation can be found in the ServiceNamespace parameter at: AWS Application Auto Scaling API Reference
	serviceNamespace?: null | string @go(ServiceNamespace,*string)

	// Key-value map of resource tags.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)

	// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
	tagsAll?: {[string]: null | string} @go(TagsAll,map[string]*string)
}

#TargetParameters: {
	// Max capacity of the scalable target.
	// +kubebuilder:validation:Optional
	maxCapacity?: null | float64 @go(MaxCapacity,*float64)

	// Min capacity of the scalable target.
	// +kubebuilder:validation:Optional
	minCapacity?: null | float64 @go(MinCapacity,*float64)

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	region?: null | string @go(Region,*string)

	// Resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the ResourceId parameter at: AWS Application Auto Scaling API Reference
	// +kubebuilder:validation:Required
	resourceId?: null | string @go(ResourceID,*string)

	// ARN of the IAM role that allows Application AutoScaling to modify your scalable target on your behalf. This defaults to an IAM Service-Linked Role for most services and custom IAM Roles are ignored by the API for those namespaces. See the AWS Application Auto Scaling documentation for more information about how this service interacts with IAM.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/iam/v1beta1.Role
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-aws/config/common.ARNExtractor()
	// +kubebuilder:validation:Optional
	roleArn?: null | string @go(RoleArn,*string)

	// Reference to a Role in iam to populate roleArn.
	// +kubebuilder:validation:Optional
	roleArnRef?: null | v1.#Reference @go(RoleArnRef,*v1.Reference)

	// Selector for a Role in iam to populate roleArn.
	// +kubebuilder:validation:Optional
	roleArnSelector?: null | v1.#Selector @go(RoleArnSelector,*v1.Selector)

	// Scalable dimension of the scalable target. Documentation can be found in the ScalableDimension parameter at: AWS Application Auto Scaling API Reference
	// +kubebuilder:validation:Required
	scalableDimension?: null | string @go(ScalableDimension,*string)

	// AWS service namespace of the scalable target. Documentation can be found in the ServiceNamespace parameter at: AWS Application Auto Scaling API Reference
	// +kubebuilder:validation:Required
	serviceNamespace?: null | string @go(ServiceNamespace,*string)

	// Key-value map of resource tags.
	// +kubebuilder:validation:Optional
	tags?: {[string]: null | string} @go(Tags,map[string]*string)
}

// TargetSpec defines the desired state of Target
#TargetSpec: {
	v1.#ResourceSpec
	forProvider: #TargetParameters @go(ForProvider)

	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #TargetInitParameters @go(InitProvider)
}

// TargetStatus defines the observed state of Target.
#TargetStatus: {
	v1.#ResourceStatus
	atProvider?: #TargetObservation @go(AtProvider)
}

// Target is the Schema for the Targets API. Provides an Application AutoScaling ScalableTarget resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
#Target: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.maxCapacity) || (has(self.initProvider) && has(self.initProvider.maxCapacity))",message="spec.forProvider.maxCapacity is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.minCapacity) || (has(self.initProvider) && has(self.initProvider.minCapacity))",message="spec.forProvider.minCapacity is a required parameter"
	spec:    #TargetSpec   @go(Spec)
	status?: #TargetStatus @go(Status)
}

// TargetList contains a list of Targets
#TargetList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#Target] @go(Items,[]Target)
}
