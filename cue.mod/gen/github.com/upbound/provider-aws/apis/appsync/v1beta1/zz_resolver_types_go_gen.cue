// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-aws/apis/appsync/v1beta1

package v1beta1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#CachingConfigInitParameters: {
	// The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
	cachingKeys?: [...null | string] @go(CachingKeys,[]*string)

	// The TTL in seconds for a resolver that has caching activated. Valid values are between 1 and 3600 seconds.
	ttl?: null | float64 @go(TTL,*float64)
}

#CachingConfigObservation: {
	// The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
	cachingKeys?: [...null | string] @go(CachingKeys,[]*string)

	// The TTL in seconds for a resolver that has caching activated. Valid values are between 1 and 3600 seconds.
	ttl?: null | float64 @go(TTL,*float64)
}

#CachingConfigParameters: {
	// The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
	// +kubebuilder:validation:Optional
	cachingKeys?: [...null | string] @go(CachingKeys,[]*string)

	// The TTL in seconds for a resolver that has caching activated. Valid values are between 1 and 3600 seconds.
	// +kubebuilder:validation:Optional
	ttl?: null | float64 @go(TTL,*float64)
}

#PipelineConfigInitParameters: {
	// A list of Function objects.
	functions?: [...null | string] @go(Functions,[]*string)
}

#PipelineConfigObservation: {
	// A list of Function objects.
	functions?: [...null | string] @go(Functions,[]*string)
}

#PipelineConfigParameters: {
	// A list of Function objects.
	// +kubebuilder:validation:Optional
	functions?: [...null | string] @go(Functions,[]*string)
}

#ResolverInitParameters: {
	// The Caching Config. See Caching Config.
	cachingConfig?: [...#CachingConfigInitParameters] @go(CachingConfig,[]CachingConfigInitParameters)

	// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
	code?: null | string @go(Code,*string)

	// Resolver type. Valid values are UNIT and PIPELINE.
	kind?: null | string @go(Kind,*string)

	// Maximum batching size for a resolver. Valid values are between 0 and 2000.
	maxBatchSize?: null | float64 @go(MaxBatchSize,*float64)

	// The caching configuration for the resolver. See Pipeline Config.
	pipelineConfig?: [...#PipelineConfigInitParameters] @go(PipelineConfig,[]PipelineConfigInitParameters)

	// Request mapping template for UNIT resolver or 'before mapping template' for PIPELINE resolver. Required for non-Lambda resolvers.
	requestTemplate?: null | string @go(RequestTemplate,*string)

	// Response mapping template for UNIT resolver or 'after mapping template' for PIPELINE resolver. Required for non-Lambda resolvers.
	responseTemplate?: null | string @go(ResponseTemplate,*string)

	// Describes a runtime used by an AWS AppSync pipeline resolver or AWS AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified. See Runtime.
	runtime?: [...#ResolverRuntimeInitParameters] @go(Runtime,[]ResolverRuntimeInitParameters)

	// Describes a Sync configuration for a resolver. See Sync Config.
	syncConfig?: [...#ResolverSyncConfigInitParameters] @go(SyncConfig,[]ResolverSyncConfigInitParameters)
}

#ResolverObservation: {
	// API ID for the GraphQL API.
	apiId?: null | string @go(APIID,*string)

	// ARN
	arn?: null | string @go(Arn,*string)

	// The Caching Config. See Caching Config.
	cachingConfig?: [...#CachingConfigObservation] @go(CachingConfig,[]CachingConfigObservation)

	// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
	code?: null | string @go(Code,*string)

	// Data source name.
	dataSource?: null | string @go(DataSource,*string)

	// Field name from the schema defined in the GraphQL API.
	field?: null | string @go(Field,*string)
	id?:    null | string @go(ID,*string)

	// Resolver type. Valid values are UNIT and PIPELINE.
	kind?: null | string @go(Kind,*string)

	// Maximum batching size for a resolver. Valid values are between 0 and 2000.
	maxBatchSize?: null | float64 @go(MaxBatchSize,*float64)

	// The caching configuration for the resolver. See Pipeline Config.
	pipelineConfig?: [...#PipelineConfigObservation] @go(PipelineConfig,[]PipelineConfigObservation)

	// Request mapping template for UNIT resolver or 'before mapping template' for PIPELINE resolver. Required for non-Lambda resolvers.
	requestTemplate?: null | string @go(RequestTemplate,*string)

	// Response mapping template for UNIT resolver or 'after mapping template' for PIPELINE resolver. Required for non-Lambda resolvers.
	responseTemplate?: null | string @go(ResponseTemplate,*string)

	// Describes a runtime used by an AWS AppSync pipeline resolver or AWS AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified. See Runtime.
	runtime?: [...#ResolverRuntimeObservation] @go(Runtime,[]ResolverRuntimeObservation)

	// Describes a Sync configuration for a resolver. See Sync Config.
	syncConfig?: [...#ResolverSyncConfigObservation] @go(SyncConfig,[]ResolverSyncConfigObservation)

	// Type name from the schema defined in the GraphQL API.
	type?: null | string @go(Type,*string)
}

#ResolverParameters: {
	// API ID for the GraphQL API.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appsync/v1beta1.GraphQLAPI
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	apiId?: null | string @go(APIID,*string)

	// Reference to a GraphQLAPI in appsync to populate apiId.
	// +kubebuilder:validation:Optional
	apiIdRef?: null | v1.#Reference @go(APIIDRef,*v1.Reference)

	// Selector for a GraphQLAPI in appsync to populate apiId.
	// +kubebuilder:validation:Optional
	apiIdSelector?: null | v1.#Selector @go(APIIDSelector,*v1.Selector)

	// The Caching Config. See Caching Config.
	// +kubebuilder:validation:Optional
	cachingConfig?: [...#CachingConfigParameters] @go(CachingConfig,[]CachingConfigParameters)

	// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
	// +kubebuilder:validation:Optional
	code?: null | string @go(Code,*string)

	// Data source name.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appsync/v1beta1.Datasource
	// +kubebuilder:validation:Optional
	dataSource?: null | string @go(DataSource,*string)

	// Reference to a Datasource in appsync to populate dataSource.
	// +kubebuilder:validation:Optional
	dataSourceRef?: null | v1.#Reference @go(DataSourceRef,*v1.Reference)

	// Selector for a Datasource in appsync to populate dataSource.
	// +kubebuilder:validation:Optional
	dataSourceSelector?: null | v1.#Selector @go(DataSourceSelector,*v1.Selector)

	// Field name from the schema defined in the GraphQL API.
	// +kubebuilder:validation:Required
	field?: null | string @go(Field,*string)

	// Resolver type. Valid values are UNIT and PIPELINE.
	// +kubebuilder:validation:Optional
	kind?: null | string @go(Kind,*string)

	// Maximum batching size for a resolver. Valid values are between 0 and 2000.
	// +kubebuilder:validation:Optional
	maxBatchSize?: null | float64 @go(MaxBatchSize,*float64)

	// The caching configuration for the resolver. See Pipeline Config.
	// +kubebuilder:validation:Optional
	pipelineConfig?: [...#PipelineConfigParameters] @go(PipelineConfig,[]PipelineConfigParameters)

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	region?: null | string @go(Region,*string)

	// Request mapping template for UNIT resolver or 'before mapping template' for PIPELINE resolver. Required for non-Lambda resolvers.
	// +kubebuilder:validation:Optional
	requestTemplate?: null | string @go(RequestTemplate,*string)

	// Response mapping template for UNIT resolver or 'after mapping template' for PIPELINE resolver. Required for non-Lambda resolvers.
	// +kubebuilder:validation:Optional
	responseTemplate?: null | string @go(ResponseTemplate,*string)

	// Describes a runtime used by an AWS AppSync pipeline resolver or AWS AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified. See Runtime.
	// +kubebuilder:validation:Optional
	runtime?: [...#ResolverRuntimeParameters] @go(Runtime,[]ResolverRuntimeParameters)

	// Describes a Sync configuration for a resolver. See Sync Config.
	// +kubebuilder:validation:Optional
	syncConfig?: [...#ResolverSyncConfigParameters] @go(SyncConfig,[]ResolverSyncConfigParameters)

	// Type name from the schema defined in the GraphQL API.
	// +kubebuilder:validation:Required
	type?: null | string @go(Type,*string)
}

#ResolverRuntimeInitParameters: {
	// The name of the runtime to use. Currently, the only allowed value is APPSYNC_JS.
	name?: null | string @go(Name,*string)

	// The version of the runtime to use. Currently, the only allowed version is 1.0.0.
	runtimeVersion?: null | string @go(RuntimeVersion,*string)
}

#ResolverRuntimeObservation: {
	// The name of the runtime to use. Currently, the only allowed value is APPSYNC_JS.
	name?: null | string @go(Name,*string)

	// The version of the runtime to use. Currently, the only allowed version is 1.0.0.
	runtimeVersion?: null | string @go(RuntimeVersion,*string)
}

#ResolverRuntimeParameters: {
	// The name of the runtime to use. Currently, the only allowed value is APPSYNC_JS.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// The version of the runtime to use. Currently, the only allowed version is 1.0.0.
	// +kubebuilder:validation:Optional
	runtimeVersion?: null | string @go(RuntimeVersion,*string)
}

#ResolverSyncConfigInitParameters: {
	// Conflict Detection strategy to use. Valid values are NONE and VERSION.
	conflictDetection?: null | string @go(ConflictDetection,*string)

	// Conflict Resolution strategy to perform in the event of a conflict. Valid values are NONE, OPTIMISTIC_CONCURRENCY, AUTOMERGE, and LAMBDA.
	conflictHandler?: null | string @go(ConflictHandler,*string)

	// Lambda Conflict Handler Config when configuring LAMBDA as the Conflict Handler. See Lambda Conflict Handler Config.
	lambdaConflictHandlerConfig?: [...#SyncConfigLambdaConflictHandlerConfigInitParameters] @go(LambdaConflictHandlerConfig,[]SyncConfigLambdaConflictHandlerConfigInitParameters)
}

#ResolverSyncConfigObservation: {
	// Conflict Detection strategy to use. Valid values are NONE and VERSION.
	conflictDetection?: null | string @go(ConflictDetection,*string)

	// Conflict Resolution strategy to perform in the event of a conflict. Valid values are NONE, OPTIMISTIC_CONCURRENCY, AUTOMERGE, and LAMBDA.
	conflictHandler?: null | string @go(ConflictHandler,*string)

	// Lambda Conflict Handler Config when configuring LAMBDA as the Conflict Handler. See Lambda Conflict Handler Config.
	lambdaConflictHandlerConfig?: [...#SyncConfigLambdaConflictHandlerConfigObservation] @go(LambdaConflictHandlerConfig,[]SyncConfigLambdaConflictHandlerConfigObservation)
}

#ResolverSyncConfigParameters: {
	// Conflict Detection strategy to use. Valid values are NONE and VERSION.
	// +kubebuilder:validation:Optional
	conflictDetection?: null | string @go(ConflictDetection,*string)

	// Conflict Resolution strategy to perform in the event of a conflict. Valid values are NONE, OPTIMISTIC_CONCURRENCY, AUTOMERGE, and LAMBDA.
	// +kubebuilder:validation:Optional
	conflictHandler?: null | string @go(ConflictHandler,*string)

	// Lambda Conflict Handler Config when configuring LAMBDA as the Conflict Handler. See Lambda Conflict Handler Config.
	// +kubebuilder:validation:Optional
	lambdaConflictHandlerConfig?: [...#SyncConfigLambdaConflictHandlerConfigParameters] @go(LambdaConflictHandlerConfig,[]SyncConfigLambdaConflictHandlerConfigParameters)
}

#SyncConfigLambdaConflictHandlerConfigInitParameters: {
	// ARN for the Lambda function to use as the Conflict Handler.
	lambdaConflictHandlerArn?: null | string @go(LambdaConflictHandlerArn,*string)
}

#SyncConfigLambdaConflictHandlerConfigObservation: {
	// ARN for the Lambda function to use as the Conflict Handler.
	lambdaConflictHandlerArn?: null | string @go(LambdaConflictHandlerArn,*string)
}

#SyncConfigLambdaConflictHandlerConfigParameters: {
	// ARN for the Lambda function to use as the Conflict Handler.
	// +kubebuilder:validation:Optional
	lambdaConflictHandlerArn?: null | string @go(LambdaConflictHandlerArn,*string)
}

// ResolverSpec defines the desired state of Resolver
#ResolverSpec: {
	v1.#ResourceSpec
	forProvider: #ResolverParameters @go(ForProvider)

	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #ResolverInitParameters @go(InitProvider)
}

// ResolverStatus defines the observed state of Resolver.
#ResolverStatus: {
	v1.#ResourceStatus
	atProvider?: #ResolverObservation @go(AtProvider)
}

// Resolver is the Schema for the Resolvers API. Provides an AppSync Resolver.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
#Resolver: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec:      #ResolverSpec      @go(Spec)
	status?:   #ResolverStatus    @go(Status)
}

// ResolverList contains a list of Resolvers
#ResolverList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#Resolver] @go(Items,[]Resolver)
}
